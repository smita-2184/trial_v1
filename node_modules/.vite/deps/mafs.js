import {
  katex
} from "./chunk-RXZSU4EN.js";
import {
  invariant
} from "./chunk-XUSVWCLU.js";
import {
  require_jsx_runtime
} from "./chunk-QRIEPQWS.js";
import {
  require_react
} from "./chunk-VJA5E53X.js";
import {
  __toESM
} from "./chunk-SNAQBZPT.js";

// node_modules/mafs/build/index.mjs
var React8 = __toESM(require_react(), 1);
var React2 = __toESM(require_react(), 1);
var React22 = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);

// node_modules/use-resize-observer/dist/bundle.esm.js
var import_react = __toESM(require_react());
function useResolvedElement(subscriber, refOrElement) {
  var lastReportRef = (0, import_react.useRef)(null);
  var refOrElementRef = (0, import_react.useRef)(null);
  refOrElementRef.current = refOrElement;
  var cbElementRef = (0, import_react.useRef)(null);
  (0, import_react.useEffect)(function() {
    evaluateSubscription();
  });
  var evaluateSubscription = (0, import_react.useCallback)(function() {
    var cbElement = cbElementRef.current;
    var refOrElement2 = refOrElementRef.current;
    var element = cbElement ? cbElement : refOrElement2 ? refOrElement2 instanceof Element ? refOrElement2 : refOrElement2.current : null;
    if (lastReportRef.current && lastReportRef.current.element === element && lastReportRef.current.subscriber === subscriber) {
      return;
    }
    if (lastReportRef.current && lastReportRef.current.cleanup) {
      lastReportRef.current.cleanup();
    }
    lastReportRef.current = {
      element,
      subscriber,
      // Only calling the subscriber, if there's an actual element to report.
      // Setting cleanup to undefined unless a subscriber returns one, as an existing cleanup function would've been just called.
      cleanup: element ? subscriber(element) : void 0
    };
  }, [subscriber]);
  (0, import_react.useEffect)(function() {
    return function() {
      if (lastReportRef.current && lastReportRef.current.cleanup) {
        lastReportRef.current.cleanup();
        lastReportRef.current = null;
      }
    };
  }, []);
  return (0, import_react.useCallback)(function(element) {
    cbElementRef.current = element;
    evaluateSubscription();
  }, [evaluateSubscription]);
}
function extractSize(entry, boxProp, sizeType) {
  if (!entry[boxProp]) {
    if (boxProp === "contentBoxSize") {
      return entry.contentRect[sizeType === "inlineSize" ? "width" : "height"];
    }
    return void 0;
  }
  return entry[boxProp][0] ? entry[boxProp][0][sizeType] : (
    // TS complains about this, because the RO entry type follows the spec and does not reflect Firefox's current
    // behaviour of returning objects instead of arrays for `borderBoxSize` and `contentBoxSize`.
    // @ts-ignore
    entry[boxProp][sizeType]
  );
}
function useResizeObserver(opts) {
  if (opts === void 0) {
    opts = {};
  }
  var onResize = opts.onResize;
  var onResizeRef = (0, import_react.useRef)(void 0);
  onResizeRef.current = onResize;
  var round3 = opts.round || Math.round;
  var resizeObserverRef = (0, import_react.useRef)();
  var _useState = (0, import_react.useState)({
    width: void 0,
    height: void 0
  }), size = _useState[0], setSize = _useState[1];
  var didUnmount = (0, import_react.useRef)(false);
  (0, import_react.useEffect)(function() {
    didUnmount.current = false;
    return function() {
      didUnmount.current = true;
    };
  }, []);
  var previous = (0, import_react.useRef)({
    width: void 0,
    height: void 0
  });
  var refCallback = useResolvedElement((0, import_react.useCallback)(function(element) {
    if (!resizeObserverRef.current || resizeObserverRef.current.box !== opts.box || resizeObserverRef.current.round !== round3) {
      resizeObserverRef.current = {
        box: opts.box,
        round: round3,
        instance: new ResizeObserver(function(entries) {
          var entry = entries[0];
          var boxProp = opts.box === "border-box" ? "borderBoxSize" : opts.box === "device-pixel-content-box" ? "devicePixelContentBoxSize" : "contentBoxSize";
          var reportedWidth = extractSize(entry, boxProp, "inlineSize");
          var reportedHeight = extractSize(entry, boxProp, "blockSize");
          var newWidth = reportedWidth ? round3(reportedWidth) : void 0;
          var newHeight = reportedHeight ? round3(reportedHeight) : void 0;
          if (previous.current.width !== newWidth || previous.current.height !== newHeight) {
            var newSize = {
              width: newWidth,
              height: newHeight
            };
            previous.current.width = newWidth;
            previous.current.height = newHeight;
            if (onResizeRef.current) {
              onResizeRef.current(newSize);
            } else {
              if (!didUnmount.current) {
                setSize(newSize);
              }
            }
          }
        })
      };
    }
    resizeObserverRef.current.instance.observe(element, {
      box: opts.box
    });
    return function() {
      if (resizeObserverRef.current) {
        resizeObserverRef.current.instance.unobserve(element);
      }
    };
  }, [opts.box, round3]), opts.ref);
  return (0, import_react.useMemo)(function() {
    return {
      ref: refCallback,
      width: size.width,
      height: size.height
    };
  }, [refCallback, size.width, size.height]);
}

// node_modules/@use-gesture/core/dist/maths-0ab39ae9.esm.js
function clamp(v, min, max) {
  return Math.max(min, Math.min(v, max));
}
var V = {
  toVector(v, fallback) {
    if (v === void 0) v = fallback;
    return Array.isArray(v) ? v : [v, v];
  },
  add(v1, v2) {
    return [v1[0] + v2[0], v1[1] + v2[1]];
  },
  sub(v1, v2) {
    return [v1[0] - v2[0], v1[1] - v2[1]];
  },
  addTo(v1, v2) {
    v1[0] += v2[0];
    v1[1] += v2[1];
  },
  subTo(v1, v2) {
    v1[0] -= v2[0];
    v1[1] -= v2[1];
  }
};
function rubberband(distance, dimension, constant) {
  if (dimension === 0 || Math.abs(dimension) === Infinity) return Math.pow(distance, constant * 5);
  return distance * dimension * constant / (dimension + constant * distance);
}
function rubberbandIfOutOfBounds(position, min, max, constant = 0.15) {
  if (constant === 0) return clamp(position, min, max);
  if (position < min) return -rubberband(min - position, max - min, constant) + min;
  if (position > max) return +rubberband(position - max, max - min, constant) + max;
  return position;
}
function computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {
  const [[X0, X1], [Y0, Y1]] = bounds;
  return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];
}

// node_modules/@use-gesture/core/dist/actions-fe213e88.esm.js
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var EVENT_TYPE_MAP = {
  pointer: {
    start: "down",
    change: "move",
    end: "up"
  },
  mouse: {
    start: "down",
    change: "move",
    end: "up"
  },
  touch: {
    start: "start",
    change: "move",
    end: "end"
  },
  gesture: {
    start: "start",
    change: "change",
    end: "end"
  }
};
function capitalize(string) {
  if (!string) return "";
  return string[0].toUpperCase() + string.slice(1);
}
var actionsWithoutCaptureSupported = ["enter", "leave"];
function hasCapture(capture = false, actionKey) {
  return capture && !actionsWithoutCaptureSupported.includes(actionKey);
}
function toHandlerProp(device, action = "", capture = false) {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action] || action : action;
  return "on" + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? "Capture" : "");
}
var pointerCaptureEvents = ["gotpointercapture", "lostpointercapture"];
function parseProp(prop) {
  let eventKey = prop.substring(2).toLowerCase();
  const passive = !!~eventKey.indexOf("passive");
  if (passive) eventKey = eventKey.replace("passive", "");
  const captureKey = pointerCaptureEvents.includes(eventKey) ? "capturecapture" : "capture";
  const capture = !!~eventKey.indexOf(captureKey);
  if (capture) eventKey = eventKey.replace("capture", "");
  return {
    device: eventKey,
    capture,
    passive
  };
}
function toDomEventType(device, action = "") {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action] || action : action;
  return device + actionKey;
}
function isTouch(event) {
  return "touches" in event;
}
function getPointerType(event) {
  if (isTouch(event)) return "touch";
  if ("pointerType" in event) return event.pointerType;
  return "mouse";
}
function getCurrentTargetTouchList(event) {
  return Array.from(event.touches).filter((e) => {
    var _event$currentTarget, _event$currentTarget$;
    return e.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 || (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e.target));
  });
}
function getTouchList(event) {
  return event.type === "touchend" || event.type === "touchcancel" ? event.changedTouches : event.targetTouches;
}
function getValueEvent(event) {
  return isTouch(event) ? getTouchList(event)[0] : event;
}
function distanceAngle(P1, P2) {
  try {
    const dx = P2.clientX - P1.clientX;
    const dy = P2.clientY - P1.clientY;
    const cx = (P2.clientX + P1.clientX) / 2;
    const cy = (P2.clientY + P1.clientY) / 2;
    const distance = Math.hypot(dx, dy);
    const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;
    const origin = [cx, cy];
    return {
      angle,
      distance,
      origin
    };
  } catch (_unused) {
  }
  return null;
}
function touchIds(event) {
  return getCurrentTargetTouchList(event).map((touch) => touch.identifier);
}
function touchDistanceAngle(event, ids) {
  const [P1, P2] = Array.from(event.touches).filter((touch) => ids.includes(touch.identifier));
  return distanceAngle(P1, P2);
}
function pointerId(event) {
  const valueEvent = getValueEvent(event);
  return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;
}
function pointerValues(event) {
  const valueEvent = getValueEvent(event);
  return [valueEvent.clientX, valueEvent.clientY];
}
var LINE_HEIGHT = 40;
var PAGE_HEIGHT = 800;
function wheelValues(event) {
  let {
    deltaX,
    deltaY,
    deltaMode
  } = event;
  if (deltaMode === 1) {
    deltaX *= LINE_HEIGHT;
    deltaY *= LINE_HEIGHT;
  } else if (deltaMode === 2) {
    deltaX *= PAGE_HEIGHT;
    deltaY *= PAGE_HEIGHT;
  }
  return [deltaX, deltaY];
}
function scrollValues(event) {
  var _ref, _ref2;
  const {
    scrollX,
    scrollY,
    scrollLeft,
    scrollTop
  } = event.currentTarget;
  return [(_ref = scrollX !== null && scrollX !== void 0 ? scrollX : scrollLeft) !== null && _ref !== void 0 ? _ref : 0, (_ref2 = scrollY !== null && scrollY !== void 0 ? scrollY : scrollTop) !== null && _ref2 !== void 0 ? _ref2 : 0];
}
function getEventDetails(event) {
  const payload = {};
  if ("buttons" in event) payload.buttons = event.buttons;
  if ("shiftKey" in event) {
    const {
      shiftKey,
      altKey,
      metaKey,
      ctrlKey
    } = event;
    Object.assign(payload, {
      shiftKey,
      altKey,
      metaKey,
      ctrlKey
    });
  }
  return payload;
}
function call(v, ...args) {
  if (typeof v === "function") {
    return v(...args);
  } else {
    return v;
  }
}
function noop() {
}
function chain(...fns) {
  if (fns.length === 0) return noop;
  if (fns.length === 1) return fns[0];
  return function() {
    let result;
    for (const fn of fns) {
      result = fn.apply(this, arguments) || result;
    }
    return result;
  };
}
function assignDefault(value, fallback) {
  return Object.assign({}, fallback, value || {});
}
var BEFORE_LAST_KINEMATICS_DELAY = 32;
var Engine = class {
  constructor(ctrl, args, key) {
    this.ctrl = ctrl;
    this.args = args;
    this.key = key;
    if (!this.state) {
      this.state = {};
      this.computeValues([0, 0]);
      this.computeInitial();
      if (this.init) this.init();
      this.reset();
    }
  }
  get state() {
    return this.ctrl.state[this.key];
  }
  set state(state) {
    this.ctrl.state[this.key] = state;
  }
  get shared() {
    return this.ctrl.state.shared;
  }
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key];
  }
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key];
  }
  get config() {
    return this.ctrl.config[this.key];
  }
  get sharedConfig() {
    return this.ctrl.config.shared;
  }
  get handler() {
    return this.ctrl.handlers[this.key];
  }
  reset() {
    const {
      state,
      shared,
      ingKey,
      args
    } = this;
    shared[ingKey] = state._active = state.active = state._blocked = state._force = false;
    state._step = [false, false];
    state.intentional = false;
    state._movement = [0, 0];
    state._distance = [0, 0];
    state._direction = [0, 0];
    state._delta = [0, 0];
    state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];
    state.args = args;
    state.axis = void 0;
    state.memo = void 0;
    state.elapsedTime = state.timeDelta = 0;
    state.direction = [0, 0];
    state.distance = [0, 0];
    state.overflow = [0, 0];
    state._movementBound = [false, false];
    state.velocity = [0, 0];
    state.movement = [0, 0];
    state.delta = [0, 0];
    state.timeStamp = 0;
  }
  start(event) {
    const state = this.state;
    const config = this.config;
    if (!state._active) {
      this.reset();
      this.computeInitial();
      state._active = true;
      state.target = event.target;
      state.currentTarget = event.currentTarget;
      state.lastOffset = config.from ? call(config.from, state) : state.offset;
      state.offset = state.lastOffset;
      state.startTime = state.timeStamp = event.timeStamp;
    }
  }
  computeValues(values) {
    const state = this.state;
    state._values = values;
    state.values = this.config.transform(values);
  }
  computeInitial() {
    const state = this.state;
    state._initial = state._values;
    state.initial = state.values;
  }
  compute(event) {
    const {
      state,
      config,
      shared
    } = this;
    state.args = this.args;
    let dt = 0;
    if (event) {
      state.event = event;
      if (config.preventDefault && event.cancelable) state.event.preventDefault();
      state.type = event.type;
      shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;
      shared.locked = !!document.pointerLockElement;
      Object.assign(shared, getEventDetails(event));
      shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;
      dt = event.timeStamp - state.timeStamp;
      state.timeStamp = event.timeStamp;
      state.elapsedTime = state.timeStamp - state.startTime;
    }
    if (state._active) {
      const _absoluteDelta = state._delta.map(Math.abs);
      V.addTo(state._distance, _absoluteDelta);
    }
    if (this.axisIntent) this.axisIntent(event);
    const [_m0, _m1] = state._movement;
    const [t0, t1] = config.threshold;
    const {
      _step,
      values
    } = state;
    if (config.hasCustomTransform) {
      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && values[0];
      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && values[1];
    } else {
      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;
      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;
    }
    state.intentional = _step[0] !== false || _step[1] !== false;
    if (!state.intentional) return;
    const movement = [0, 0];
    if (config.hasCustomTransform) {
      const [v0, v1] = values;
      movement[0] = _step[0] !== false ? v0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? v1 - _step[1] : 0;
    } else {
      movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;
    }
    if (this.restrictToAxis && !state._blocked) this.restrictToAxis(movement);
    const previousOffset = state.offset;
    const gestureIsActive = state._active && !state._blocked || state.active;
    if (gestureIsActive) {
      state.first = state._active && !state.active;
      state.last = !state._active && state.active;
      state.active = shared[this.ingKey] = state._active;
      if (event) {
        if (state.first) {
          if ("bounds" in config) state._bounds = call(config.bounds, state);
          if (this.setup) this.setup();
        }
        state.movement = movement;
        this.computeOffset();
      }
    }
    const [ox, oy] = state.offset;
    const [[x0, x1], [y0, y1]] = state._bounds;
    state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];
    state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;
    state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;
    const rubberband2 = state._active ? config.rubberband || [0, 0] : [0, 0];
    state.offset = computeRubberband(state._bounds, state.offset, rubberband2);
    state.delta = V.sub(state.offset, previousOffset);
    this.computeMovement();
    if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {
      state.delta = V.sub(state.offset, previousOffset);
      const absoluteDelta = state.delta.map(Math.abs);
      V.addTo(state.distance, absoluteDelta);
      state.direction = state.delta.map(Math.sign);
      state._direction = state._delta.map(Math.sign);
      if (!state.first && dt > 0) {
        state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];
        state.timeDelta = dt;
      }
    }
  }
  emit() {
    const state = this.state;
    const shared = this.shared;
    const config = this.config;
    if (!state._active) this.clean();
    if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents) return;
    const memo = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, {
      [this.aliasKey]: state.values
    }));
    if (memo !== void 0) state.memo = memo;
  }
  clean() {
    this.eventStore.clean();
    this.timeoutStore.clean();
  }
};
function selectAxis([dx, dy], threshold) {
  const absDx = Math.abs(dx);
  const absDy = Math.abs(dy);
  if (absDx > absDy && absDx > threshold) {
    return "x";
  }
  if (absDy > absDx && absDy > threshold) {
    return "y";
  }
  return void 0;
}
var CoordinatesEngine = class extends Engine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "aliasKey", "xy");
  }
  reset() {
    super.reset();
    this.state.axis = void 0;
  }
  init() {
    this.state.offset = [0, 0];
    this.state.lastOffset = [0, 0];
  }
  computeOffset() {
    this.state.offset = V.add(this.state.lastOffset, this.state.movement);
  }
  computeMovement() {
    this.state.movement = V.sub(this.state.offset, this.state.lastOffset);
  }
  axisIntent(event) {
    const state = this.state;
    const config = this.config;
    if (!state.axis && event) {
      const threshold = typeof config.axisThreshold === "object" ? config.axisThreshold[getPointerType(event)] : config.axisThreshold;
      state.axis = selectAxis(state._movement, threshold);
    }
    state._blocked = (config.lockDirection || !!config.axis) && !state.axis || !!config.axis && config.axis !== state.axis;
  }
  restrictToAxis(v) {
    if (this.config.axis || this.config.lockDirection) {
      switch (this.state.axis) {
        case "x":
          v[1] = 0;
          break;
        case "y":
          v[0] = 0;
          break;
      }
    }
  }
};
var identity = (v) => v;
var DEFAULT_RUBBERBAND = 0.15;
var commonConfigResolver = {
  enabled(value = true) {
    return value;
  },
  eventOptions(value, _k, config) {
    return _objectSpread2(_objectSpread2({}, config.shared.eventOptions), value);
  },
  preventDefault(value = false) {
    return value;
  },
  triggerAllEvents(value = false) {
    return value;
  },
  rubberband(value = 0) {
    switch (value) {
      case true:
        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];
      case false:
        return [0, 0];
      default:
        return V.toVector(value);
    }
  },
  from(value) {
    if (typeof value === "function") return value;
    if (value != null) return V.toVector(value);
  },
  transform(value, _k, config) {
    const transform = value || config.shared.transform;
    this.hasCustomTransform = !!transform;
    if (true) {
      const originalTransform = transform || identity;
      return (v) => {
        const r = originalTransform(v);
        if (!isFinite(r[0]) || !isFinite(r[1])) {
          console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${r[0]},${[1]}]`);
        }
        return r;
      };
    }
    return transform || identity;
  },
  threshold(value) {
    return V.toVector(value, 0);
  }
};
if (true) {
  Object.assign(commonConfigResolver, {
    domTarget(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
      }
      return NaN;
    },
    lockDirection(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`lockDirection\` option has been merged with \`axis\`. Use it as in \`{ axis: 'lock' }\``);
      }
      return NaN;
    },
    initial(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`initial\` option has been renamed to \`from\`.`);
      }
      return NaN;
    }
  });
}
var DEFAULT_AXIS_THRESHOLD = 0;
var coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
  axis(_v, _k, {
    axis
  }) {
    this.lockDirection = axis === "lock";
    if (!this.lockDirection) return axis;
  },
  axisThreshold(value = DEFAULT_AXIS_THRESHOLD) {
    return value;
  },
  bounds(value = {}) {
    if (typeof value === "function") {
      return (state) => coordinatesConfigResolver.bounds(value(state));
    }
    if ("current" in value) {
      return () => value.current;
    }
    if (typeof HTMLElement === "function" && value instanceof HTMLElement) {
      return value;
    }
    const {
      left = -Infinity,
      right = Infinity,
      top = -Infinity,
      bottom = Infinity
    } = value;
    return [[left, right], [top, bottom]];
  }
});
var KEYS_DELTA_MAP = {
  ArrowRight: (displacement, factor = 1) => [displacement * factor, 0],
  ArrowLeft: (displacement, factor = 1) => [-1 * displacement * factor, 0],
  ArrowUp: (displacement, factor = 1) => [0, -1 * displacement * factor],
  ArrowDown: (displacement, factor = 1) => [0, displacement * factor]
};
var DragEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "dragging");
  }
  reset() {
    super.reset();
    const state = this.state;
    state._pointerId = void 0;
    state._pointerActive = false;
    state._keyboardActive = false;
    state._preventScroll = false;
    state._delayed = false;
    state.swipe = [0, 0];
    state.tap = false;
    state.canceled = false;
    state.cancel = this.cancel.bind(this);
  }
  setup() {
    const state = this.state;
    if (state._bounds instanceof HTMLElement) {
      const boundRect = state._bounds.getBoundingClientRect();
      const targetRect = state.currentTarget.getBoundingClientRect();
      const _bounds = {
        left: boundRect.left - targetRect.left + state.offset[0],
        right: boundRect.right - targetRect.right + state.offset[0],
        top: boundRect.top - targetRect.top + state.offset[1],
        bottom: boundRect.bottom - targetRect.bottom + state.offset[1]
      };
      state._bounds = coordinatesConfigResolver.bounds(_bounds);
    }
  }
  cancel() {
    const state = this.state;
    if (state.canceled) return;
    state.canceled = true;
    state._active = false;
    setTimeout(() => {
      this.compute();
      this.emit();
    }, 0);
  }
  setActive() {
    this.state._active = this.state._pointerActive || this.state._keyboardActive;
  }
  clean() {
    this.pointerClean();
    this.state._pointerActive = false;
    this.state._keyboardActive = false;
    super.clean();
  }
  pointerDown(event) {
    const config = this.config;
    const state = this.state;
    if (event.buttons != null && (Array.isArray(config.pointerButtons) ? !config.pointerButtons.includes(event.buttons) : config.pointerButtons !== -1 && config.pointerButtons !== event.buttons)) return;
    const ctrlIds = this.ctrl.setEventIds(event);
    if (config.pointerCapture) {
      event.target.setPointerCapture(event.pointerId);
    }
    if (ctrlIds && ctrlIds.size > 1 && state._pointerActive) return;
    this.start(event);
    this.setupPointer(event);
    state._pointerId = pointerId(event);
    state._pointerActive = true;
    this.computeValues(pointerValues(event));
    this.computeInitial();
    if (config.preventScrollAxis && getPointerType(event) !== "mouse") {
      state._active = false;
      this.setupScrollPrevention(event);
    } else if (config.delay > 0) {
      this.setupDelayTrigger(event);
      if (config.triggerAllEvents) {
        this.compute(event);
        this.emit();
      }
    } else {
      this.startPointerDrag(event);
    }
  }
  startPointerDrag(event) {
    const state = this.state;
    state._active = true;
    state._preventScroll = true;
    state._delayed = false;
    this.compute(event);
    this.emit();
  }
  pointerMove(event) {
    const state = this.state;
    const config = this.config;
    if (!state._pointerActive) return;
    const id = pointerId(event);
    if (state._pointerId !== void 0 && id !== state._pointerId) return;
    const _values = pointerValues(event);
    if (document.pointerLockElement === event.target) {
      state._delta = [event.movementX, event.movementY];
    } else {
      state._delta = V.sub(_values, state._values);
      this.computeValues(_values);
    }
    V.addTo(state._movement, state._delta);
    this.compute(event);
    if (state._delayed && state.intentional) {
      this.timeoutStore.remove("dragDelay");
      state.active = false;
      this.startPointerDrag(event);
      return;
    }
    if (config.preventScrollAxis && !state._preventScroll) {
      if (state.axis) {
        if (state.axis === config.preventScrollAxis || config.preventScrollAxis === "xy") {
          state._active = false;
          this.clean();
          return;
        } else {
          this.timeoutStore.remove("startPointerDrag");
          this.startPointerDrag(event);
          return;
        }
      } else {
        return;
      }
    }
    this.emit();
  }
  pointerUp(event) {
    this.ctrl.setEventIds(event);
    try {
      if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {
        ;
        event.target.releasePointerCapture(event.pointerId);
      }
    } catch (_unused) {
      if (true) {
        console.warn(`[@use-gesture]: If you see this message, it's likely that you're using an outdated version of \`@react-three/fiber\`. 

Please upgrade to the latest version.`);
      }
    }
    const state = this.state;
    const config = this.config;
    if (!state._active || !state._pointerActive) return;
    const id = pointerId(event);
    if (state._pointerId !== void 0 && id !== state._pointerId) return;
    this.state._pointerActive = false;
    this.setActive();
    this.compute(event);
    const [dx, dy] = state._distance;
    state.tap = dx <= config.tapsThreshold && dy <= config.tapsThreshold;
    if (state.tap && config.filterTaps) {
      state._force = true;
    } else {
      const [_dx, _dy] = state._delta;
      const [_mx, _my] = state._movement;
      const [svx, svy] = config.swipe.velocity;
      const [sx, sy] = config.swipe.distance;
      const sdt = config.swipe.duration;
      if (state.elapsedTime < sdt) {
        const _vx = Math.abs(_dx / state.timeDelta);
        const _vy = Math.abs(_dy / state.timeDelta);
        if (_vx > svx && Math.abs(_mx) > sx) state.swipe[0] = Math.sign(_dx);
        if (_vy > svy && Math.abs(_my) > sy) state.swipe[1] = Math.sign(_dy);
      }
    }
    this.emit();
  }
  pointerClick(event) {
    if (!this.state.tap && event.detail > 0) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  setupPointer(event) {
    const config = this.config;
    const device = config.device;
    if (true) {
      try {
        if (device === "pointer" && config.preventScrollDelay === void 0) {
          const currentTarget = "uv" in event ? event.sourceEvent.currentTarget : event.currentTarget;
          const style = window.getComputedStyle(currentTarget);
          if (style.touchAction === "auto") {
            console.warn(`[@use-gesture]: The drag target has its \`touch-action\` style property set to \`auto\`. It is recommended to add \`touch-action: 'none'\` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.

This message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.`, currentTarget);
          }
        }
      } catch (_unused2) {
      }
    }
    if (config.pointerLock) {
      event.currentTarget.requestPointerLock();
    }
    if (!config.pointerCapture) {
      this.eventStore.add(this.sharedConfig.window, device, "change", this.pointerMove.bind(this));
      this.eventStore.add(this.sharedConfig.window, device, "end", this.pointerUp.bind(this));
      this.eventStore.add(this.sharedConfig.window, device, "cancel", this.pointerUp.bind(this));
    }
  }
  pointerClean() {
    if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {
      document.exitPointerLock();
    }
  }
  preventScroll(event) {
    if (this.state._preventScroll && event.cancelable) {
      event.preventDefault();
    }
  }
  setupScrollPrevention(event) {
    this.state._preventScroll = false;
    persistEvent(event);
    const remove = this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
      passive: false
    });
    this.eventStore.add(this.sharedConfig.window, "touch", "end", remove);
    this.eventStore.add(this.sharedConfig.window, "touch", "cancel", remove);
    this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScrollDelay, event);
  }
  setupDelayTrigger(event) {
    this.state._delayed = true;
    this.timeoutStore.add("dragDelay", () => {
      this.state._step = [0, 0];
      this.startPointerDrag(event);
    }, this.config.delay);
  }
  keyDown(event) {
    const deltaFn = KEYS_DELTA_MAP[event.key];
    if (deltaFn) {
      const state = this.state;
      const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;
      this.start(event);
      state._delta = deltaFn(this.config.keyboardDisplacement, factor);
      state._keyboardActive = true;
      V.addTo(state._movement, state._delta);
      this.compute(event);
      this.emit();
    }
  }
  keyUp(event) {
    if (!(event.key in KEYS_DELTA_MAP)) return;
    this.state._keyboardActive = false;
    this.setActive();
    this.compute(event);
    this.emit();
  }
  bind(bindFunction) {
    const device = this.config.device;
    bindFunction(device, "start", this.pointerDown.bind(this));
    if (this.config.pointerCapture) {
      bindFunction(device, "change", this.pointerMove.bind(this));
      bindFunction(device, "end", this.pointerUp.bind(this));
      bindFunction(device, "cancel", this.pointerUp.bind(this));
      bindFunction("lostPointerCapture", "", this.pointerUp.bind(this));
    }
    if (this.config.keys) {
      bindFunction("key", "down", this.keyDown.bind(this));
      bindFunction("key", "up", this.keyUp.bind(this));
    }
    if (this.config.filterTaps) {
      bindFunction("click", "", this.pointerClick.bind(this), {
        capture: true,
        passive: false
      });
    }
  }
};
function persistEvent(event) {
  "persist" in event && typeof event.persist === "function" && event.persist();
}
var isBrowser = typeof window !== "undefined" && window.document && window.document.createElement;
function supportsTouchEvents() {
  return isBrowser && "ontouchstart" in window;
}
function isTouchScreen() {
  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;
}
function supportsPointerEvents() {
  return isBrowser && "onpointerdown" in window;
}
function supportsPointerLock() {
  return isBrowser && "exitPointerLock" in window.document;
}
function supportsGestureEvents() {
  try {
    return "constructor" in GestureEvent;
  } catch (e) {
    return false;
  }
}
var SUPPORT = {
  isBrowser,
  gesture: supportsGestureEvents(),
  touch: supportsTouchEvents(),
  touchscreen: isTouchScreen(),
  pointer: supportsPointerEvents(),
  pointerLock: supportsPointerLock()
};
var DEFAULT_PREVENT_SCROLL_DELAY = 250;
var DEFAULT_DRAG_DELAY = 180;
var DEFAULT_SWIPE_VELOCITY = 0.5;
var DEFAULT_SWIPE_DISTANCE = 50;
var DEFAULT_SWIPE_DURATION = 250;
var DEFAULT_KEYBOARD_DISPLACEMENT = 10;
var DEFAULT_DRAG_AXIS_THRESHOLD = {
  mouse: 0,
  touch: 0,
  pen: 8
};
var dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  device(_v, _k, {
    pointer: {
      touch = false,
      lock = false,
      mouse = false
    } = {}
  }) {
    this.pointerLock = lock && SUPPORT.pointerLock;
    if (SUPPORT.touch && touch) return "touch";
    if (this.pointerLock) return "mouse";
    if (SUPPORT.pointer && !mouse) return "pointer";
    if (SUPPORT.touch) return "touch";
    return "mouse";
  },
  preventScrollAxis(value, _k, {
    preventScroll
  }) {
    this.preventScrollDelay = typeof preventScroll === "number" ? preventScroll : preventScroll || preventScroll === void 0 && value ? DEFAULT_PREVENT_SCROLL_DELAY : void 0;
    if (!SUPPORT.touchscreen || preventScroll === false) return void 0;
    return value ? value : preventScroll !== void 0 ? "y" : void 0;
  },
  pointerCapture(_v, _k, {
    pointer: {
      capture = true,
      buttons = 1,
      keys = true
    } = {}
  }) {
    this.pointerButtons = buttons;
    this.keys = keys;
    return !this.pointerLock && this.device === "pointer" && capture;
  },
  threshold(value, _k, {
    filterTaps = false,
    tapsThreshold = 3,
    axis = void 0
  }) {
    const threshold = V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);
    this.filterTaps = filterTaps;
    this.tapsThreshold = tapsThreshold;
    return threshold;
  },
  swipe({
    velocity = DEFAULT_SWIPE_VELOCITY,
    distance = DEFAULT_SWIPE_DISTANCE,
    duration = DEFAULT_SWIPE_DURATION
  } = {}) {
    return {
      velocity: this.transform(V.toVector(velocity)),
      distance: this.transform(V.toVector(distance)),
      duration
    };
  },
  delay(value = 0) {
    switch (value) {
      case true:
        return DEFAULT_DRAG_DELAY;
      case false:
        return 0;
      default:
        return value;
    }
  },
  axisThreshold(value) {
    if (!value) return DEFAULT_DRAG_AXIS_THRESHOLD;
    return _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);
  },
  keyboardDisplacement(value = DEFAULT_KEYBOARD_DISPLACEMENT) {
    return value;
  }
});
if (true) {
  Object.assign(dragConfigResolver, {
    useTouch(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`useTouch\` option has been renamed to \`pointer.touch\`. Use it as in \`{ pointer: { touch: true } }\`.`);
      }
      return NaN;
    },
    experimental_preventWindowScrollY(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`experimental_preventWindowScrollY\` option has been renamed to \`preventScroll\`.`);
      }
      return NaN;
    },
    swipeVelocity(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeVelocity\` option has been renamed to \`swipe.velocity\`. Use it as in \`{ swipe: { velocity: 0.5 } }\`.`);
      }
      return NaN;
    },
    swipeDistance(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeDistance\` option has been renamed to \`swipe.distance\`. Use it as in \`{ swipe: { distance: 50 } }\`.`);
      }
      return NaN;
    },
    swipeDuration(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeDuration\` option has been renamed to \`swipe.duration\`. Use it as in \`{ swipe: { duration: 250 } }\`.`);
      }
      return NaN;
    }
  });
}
function clampStateInternalMovementToBounds(state) {
  const [ox, oy] = state.overflow;
  const [dx, dy] = state._delta;
  const [dirx, diry] = state._direction;
  if (ox < 0 && dx > 0 && dirx < 0 || ox > 0 && dx < 0 && dirx > 0) {
    state._movement[0] = state._movementBound[0];
  }
  if (oy < 0 && dy > 0 && diry < 0 || oy > 0 && dy < 0 && diry > 0) {
    state._movement[1] = state._movementBound[1];
  }
}
var SCALE_ANGLE_RATIO_INTENT_DEG = 30;
var PINCH_WHEEL_RATIO = 100;
var PinchEngine = class extends Engine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "pinching");
    _defineProperty(this, "aliasKey", "da");
  }
  init() {
    this.state.offset = [1, 0];
    this.state.lastOffset = [1, 0];
    this.state._pointerEvents = /* @__PURE__ */ new Map();
  }
  reset() {
    super.reset();
    const state = this.state;
    state._touchIds = [];
    state.canceled = false;
    state.cancel = this.cancel.bind(this);
    state.turns = 0;
  }
  computeOffset() {
    const {
      type,
      movement,
      lastOffset
    } = this.state;
    if (type === "wheel") {
      this.state.offset = V.add(movement, lastOffset);
    } else {
      this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];
    }
  }
  computeMovement() {
    const {
      offset,
      lastOffset
    } = this.state;
    this.state.movement = [offset[0] / lastOffset[0], offset[1] - lastOffset[1]];
  }
  axisIntent() {
    const state = this.state;
    const [_m0, _m1] = state._movement;
    if (!state.axis) {
      const axisMovementDifference = Math.abs(_m0) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(_m1);
      if (axisMovementDifference < 0) state.axis = "angle";
      else if (axisMovementDifference > 0) state.axis = "scale";
    }
  }
  restrictToAxis(v) {
    if (this.config.lockDirection) {
      if (this.state.axis === "scale") v[1] = 0;
      else if (this.state.axis === "angle") v[0] = 0;
    }
  }
  cancel() {
    const state = this.state;
    if (state.canceled) return;
    setTimeout(() => {
      state.canceled = true;
      state._active = false;
      this.compute();
      this.emit();
    }, 0);
  }
  touchStart(event) {
    this.ctrl.setEventIds(event);
    const state = this.state;
    const ctrlTouchIds = this.ctrl.touchIds;
    if (state._active) {
      if (state._touchIds.every((id) => ctrlTouchIds.has(id))) return;
    }
    if (ctrlTouchIds.size < 2) return;
    this.start(event);
    state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);
    const payload = touchDistanceAngle(event, state._touchIds);
    if (!payload) return;
    this.pinchStart(event, payload);
  }
  pointerStart(event) {
    if (event.buttons != null && event.buttons % 2 !== 1) return;
    this.ctrl.setEventIds(event);
    event.target.setPointerCapture(event.pointerId);
    const state = this.state;
    const _pointerEvents = state._pointerEvents;
    const ctrlPointerIds = this.ctrl.pointerIds;
    if (state._active) {
      if (Array.from(_pointerEvents.keys()).every((id) => ctrlPointerIds.has(id))) return;
    }
    if (_pointerEvents.size < 2) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (state._pointerEvents.size < 2) return;
    this.start(event);
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    if (!payload) return;
    this.pinchStart(event, payload);
  }
  pinchStart(event, payload) {
    const state = this.state;
    state.origin = payload.origin;
    this.computeValues([payload.distance, payload.angle]);
    this.computeInitial();
    this.compute(event);
    this.emit();
  }
  touchMove(event) {
    if (!this.state._active) return;
    const payload = touchDistanceAngle(event, this.state._touchIds);
    if (!payload) return;
    this.pinchMove(event, payload);
  }
  pointerMove(event) {
    const _pointerEvents = this.state._pointerEvents;
    if (_pointerEvents.has(event.pointerId)) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (!this.state._active) return;
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    if (!payload) return;
    this.pinchMove(event, payload);
  }
  pinchMove(event, payload) {
    const state = this.state;
    const prev_a = state._values[1];
    const delta_a = payload.angle - prev_a;
    let delta_turns = 0;
    if (Math.abs(delta_a) > 270) delta_turns += Math.sign(delta_a);
    this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);
    state.origin = payload.origin;
    state.turns = delta_turns;
    state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];
    this.compute(event);
    this.emit();
  }
  touchEnd(event) {
    this.ctrl.setEventIds(event);
    if (!this.state._active) return;
    if (this.state._touchIds.some((id) => !this.ctrl.touchIds.has(id))) {
      this.state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  pointerEnd(event) {
    const state = this.state;
    this.ctrl.setEventIds(event);
    try {
      event.target.releasePointerCapture(event.pointerId);
    } catch (_unused) {
    }
    if (state._pointerEvents.has(event.pointerId)) {
      state._pointerEvents.delete(event.pointerId);
    }
    if (!state._active) return;
    if (state._pointerEvents.size < 2) {
      state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  gestureStart(event) {
    if (event.cancelable) event.preventDefault();
    const state = this.state;
    if (state._active) return;
    this.start(event);
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  gestureMove(event) {
    if (event.cancelable) event.preventDefault();
    if (!this.state._active) return;
    const state = this.state;
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    const _previousMovement = state._movement;
    state._movement = [event.scale - 1, event.rotation];
    state._delta = V.sub(state._movement, _previousMovement);
    this.compute(event);
    this.emit();
  }
  gestureEnd(event) {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute(event);
    this.emit();
  }
  wheel(event) {
    const modifierKey = this.config.modifierKey;
    if (modifierKey && (Array.isArray(modifierKey) ? !modifierKey.find((k) => event[k]) : !event[modifierKey])) return;
    if (!this.state._active) this.wheelStart(event);
    else this.wheelChange(event);
    this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelStart(event) {
    this.start(event);
    this.wheelChange(event);
  }
  wheelChange(event) {
    const isR3f = "uv" in event;
    if (!isR3f) {
      if (event.cancelable) {
        event.preventDefault();
      }
      if (!event.defaultPrevented) {
        console.warn(`[@use-gesture]: To properly support zoom on trackpads, try using the \`target\` option.

This message will only appear in development mode.`);
      }
    }
    const state = this.state;
    state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];
    V.addTo(state._movement, state._delta);
    clampStateInternalMovementToBounds(state);
    this.state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    const device = this.config.device;
    if (!!device) {
      bindFunction(device, "start", this[device + "Start"].bind(this));
      bindFunction(device, "change", this[device + "Move"].bind(this));
      bindFunction(device, "end", this[device + "End"].bind(this));
      bindFunction(device, "cancel", this[device + "End"].bind(this));
      bindFunction("lostPointerCapture", "", this[device + "End"].bind(this));
    }
    if (this.config.pinchOnWheel) {
      bindFunction("wheel", "", this.wheel.bind(this), {
        passive: false
      });
    }
  }
};
var pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
  device(_v, _k, {
    shared,
    pointer: {
      touch = false
    } = {}
  }) {
    const sharedConfig = shared;
    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture) return "gesture";
    if (SUPPORT.touch && touch) return "touch";
    if (SUPPORT.touchscreen) {
      if (SUPPORT.pointer) return "pointer";
      if (SUPPORT.touch) return "touch";
    }
  },
  bounds(_v, _k, {
    scaleBounds = {},
    angleBounds = {}
  }) {
    const _scaleBounds = (state) => {
      const D = assignDefault(call(scaleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [D.min, D.max];
    };
    const _angleBounds = (state) => {
      const A = assignDefault(call(angleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [A.min, A.max];
    };
    if (typeof scaleBounds !== "function" && typeof angleBounds !== "function") return [_scaleBounds(), _angleBounds()];
    return (state) => [_scaleBounds(state), _angleBounds(state)];
  },
  threshold(value, _k, config) {
    this.lockDirection = config.axis === "lock";
    const threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0);
    return threshold;
  },
  modifierKey(value) {
    if (value === void 0) return "ctrlKey";
    return value;
  },
  pinchOnWheel(value = true) {
    return value;
  }
});
var MoveEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "moving");
  }
  move(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse") return;
    if (!this.state._active) this.moveStart(event);
    else this.moveChange(event);
    this.timeoutStore.add("moveEnd", this.moveEnd.bind(this));
  }
  moveStart(event) {
    this.start(event);
    this.computeValues(pointerValues(event));
    this.compute(event);
    this.computeInitial();
    this.emit();
  }
  moveChange(event) {
    if (!this.state._active) return;
    const values = pointerValues(event);
    const state = this.state;
    state._delta = V.sub(values, state._values);
    V.addTo(state._movement, state._delta);
    this.computeValues(values);
    this.compute(event);
    this.emit();
  }
  moveEnd(event) {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute(event);
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("pointer", "change", this.move.bind(this));
    bindFunction("pointer", "leave", this.moveEnd.bind(this));
  }
};
var moveConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  mouseOnly: (value = true) => value
});
var ScrollEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "scrolling");
  }
  scroll(event) {
    if (!this.state._active) this.start(event);
    this.scrollChange(event);
    this.timeoutStore.add("scrollEnd", this.scrollEnd.bind(this));
  }
  scrollChange(event) {
    if (event.cancelable) event.preventDefault();
    const state = this.state;
    const values = scrollValues(event);
    state._delta = V.sub(values, state._values);
    V.addTo(state._movement, state._delta);
    this.computeValues(values);
    this.compute(event);
    this.emit();
  }
  scrollEnd() {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("scroll", "", this.scroll.bind(this));
  }
};
var scrollConfigResolver = coordinatesConfigResolver;
var WheelEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "wheeling");
  }
  wheel(event) {
    if (!this.state._active) this.start(event);
    this.wheelChange(event);
    this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelChange(event) {
    const state = this.state;
    state._delta = wheelValues(event);
    V.addTo(state._movement, state._delta);
    clampStateInternalMovementToBounds(state);
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("wheel", "", this.wheel.bind(this));
  }
};
var wheelConfigResolver = coordinatesConfigResolver;
var HoverEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "hovering");
  }
  enter(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse") return;
    this.start(event);
    this.computeValues(pointerValues(event));
    this.compute(event);
    this.emit();
  }
  leave(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse") return;
    const state = this.state;
    if (!state._active) return;
    state._active = false;
    const values = pointerValues(event);
    state._movement = state._delta = V.sub(values, state._values);
    this.computeValues(values);
    this.compute(event);
    state.delta = state.movement;
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("pointer", "enter", this.enter.bind(this));
    bindFunction("pointer", "leave", this.leave.bind(this));
  }
};
var hoverConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  mouseOnly: (value = true) => value
});
var EngineMap = /* @__PURE__ */ new Map();
var ConfigResolverMap = /* @__PURE__ */ new Map();
function registerAction(action) {
  EngineMap.set(action.key, action.engine);
  ConfigResolverMap.set(action.key, action.resolver);
}
var dragAction = {
  key: "drag",
  engine: DragEngine,
  resolver: dragConfigResolver
};
var hoverAction = {
  key: "hover",
  engine: HoverEngine,
  resolver: hoverConfigResolver
};
var moveAction = {
  key: "move",
  engine: MoveEngine,
  resolver: moveConfigResolver
};
var pinchAction = {
  key: "pinch",
  engine: PinchEngine,
  resolver: pinchConfigResolver
};
var scrollAction = {
  key: "scroll",
  engine: ScrollEngine,
  resolver: scrollConfigResolver
};
var wheelAction = {
  key: "wheel",
  engine: WheelEngine,
  resolver: wheelConfigResolver
};

// node_modules/@use-gesture/react/dist/use-gesture-react.esm.js
var import_react2 = __toESM(require_react());

// node_modules/@use-gesture/core/dist/use-gesture-core.esm.js
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
var sharedConfigResolver = {
  target(value) {
    if (value) {
      return () => "current" in value ? value.current : value;
    }
    return void 0;
  },
  enabled(value = true) {
    return value;
  },
  window(value = SUPPORT.isBrowser ? window : void 0) {
    return value;
  },
  eventOptions({
    passive = true,
    capture = false
  } = {}) {
    return {
      passive,
      capture
    };
  },
  transform(value) {
    return value;
  }
};
var _excluded = ["target", "eventOptions", "window", "enabled", "transform"];
function resolveWith(config = {}, resolvers) {
  const result = {};
  for (const [key, resolver] of Object.entries(resolvers)) {
    switch (typeof resolver) {
      case "function":
        if (true) {
          const r = resolver.call(result, config[key], key, config);
          if (!Number.isNaN(r)) result[key] = r;
        } else {
          result[key] = resolver.call(result, config[key], key, config);
        }
        break;
      case "object":
        result[key] = resolveWith(config[key], resolver);
        break;
      case "boolean":
        if (resolver) result[key] = config[key];
        break;
    }
  }
  return result;
}
function parse(newConfig, gestureKey, _config = {}) {
  const _ref = newConfig, {
    target,
    eventOptions,
    window: window2,
    enabled,
    transform
  } = _ref, rest = _objectWithoutProperties(_ref, _excluded);
  _config.shared = resolveWith({
    target,
    eventOptions,
    window: window2,
    enabled,
    transform
  }, sharedConfigResolver);
  if (gestureKey) {
    const resolver = ConfigResolverMap.get(gestureKey);
    _config[gestureKey] = resolveWith(_objectSpread2({
      shared: _config.shared
    }, rest), resolver);
  } else {
    for (const key in rest) {
      const resolver = ConfigResolverMap.get(key);
      if (resolver) {
        _config[key] = resolveWith(_objectSpread2({
          shared: _config.shared
        }, rest[key]), resolver);
      } else if (true) {
        if (!["drag", "pinch", "scroll", "wheel", "move", "hover"].includes(key)) {
          if (key === "domTarget") {
            throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
          }
          console.warn(`[@use-gesture]: Unknown config key \`${key}\` was used. Please read the documentation for further information.`);
        }
      }
    }
  }
  return _config;
}
var EventStore = class {
  constructor(ctrl, gestureKey) {
    _defineProperty(this, "_listeners", /* @__PURE__ */ new Set());
    this._ctrl = ctrl;
    this._gestureKey = gestureKey;
  }
  add(element, device, action, handler, options) {
    const listeners = this._listeners;
    const type = toDomEventType(device, action);
    const _options = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {};
    const eventOptions = _objectSpread2(_objectSpread2({}, _options), options);
    element.addEventListener(type, handler, eventOptions);
    const remove = () => {
      element.removeEventListener(type, handler, eventOptions);
      listeners.delete(remove);
    };
    listeners.add(remove);
    return remove;
  }
  clean() {
    this._listeners.forEach((remove) => remove());
    this._listeners.clear();
  }
};
var TimeoutStore = class {
  constructor() {
    _defineProperty(this, "_timeouts", /* @__PURE__ */ new Map());
  }
  add(key, callback, ms = 140, ...args) {
    this.remove(key);
    this._timeouts.set(key, window.setTimeout(callback, ms, ...args));
  }
  remove(key) {
    const timeout = this._timeouts.get(key);
    if (timeout) window.clearTimeout(timeout);
  }
  clean() {
    this._timeouts.forEach((timeout) => void window.clearTimeout(timeout));
    this._timeouts.clear();
  }
};
var Controller = class {
  constructor(handlers) {
    _defineProperty(this, "gestures", /* @__PURE__ */ new Set());
    _defineProperty(this, "_targetEventStore", new EventStore(this));
    _defineProperty(this, "gestureEventStores", {});
    _defineProperty(this, "gestureTimeoutStores", {});
    _defineProperty(this, "handlers", {});
    _defineProperty(this, "config", {});
    _defineProperty(this, "pointerIds", /* @__PURE__ */ new Set());
    _defineProperty(this, "touchIds", /* @__PURE__ */ new Set());
    _defineProperty(this, "state", {
      shared: {
        shiftKey: false,
        metaKey: false,
        ctrlKey: false,
        altKey: false
      }
    });
    resolveGestures(this, handlers);
  }
  setEventIds(event) {
    if (isTouch(event)) {
      this.touchIds = new Set(touchIds(event));
      return this.touchIds;
    } else if ("pointerId" in event) {
      if (event.type === "pointerup" || event.type === "pointercancel") this.pointerIds.delete(event.pointerId);
      else if (event.type === "pointerdown") this.pointerIds.add(event.pointerId);
      return this.pointerIds;
    }
  }
  applyHandlers(handlers, nativeHandlers) {
    this.handlers = handlers;
    this.nativeHandlers = nativeHandlers;
  }
  applyConfig(config, gestureKey) {
    this.config = parse(config, gestureKey, this.config);
  }
  clean() {
    this._targetEventStore.clean();
    for (const key of this.gestures) {
      this.gestureEventStores[key].clean();
      this.gestureTimeoutStores[key].clean();
    }
  }
  effect() {
    if (this.config.shared.target) this.bind();
    return () => this._targetEventStore.clean();
  }
  bind(...args) {
    const sharedConfig = this.config.shared;
    const props = {};
    let target;
    if (sharedConfig.target) {
      target = sharedConfig.target();
      if (!target) return;
    }
    if (sharedConfig.enabled) {
      for (const gestureKey of this.gestures) {
        const gestureConfig = this.config[gestureKey];
        const bindFunction = bindToProps(props, gestureConfig.eventOptions, !!target);
        if (gestureConfig.enabled) {
          const Engine2 = EngineMap.get(gestureKey);
          new Engine2(this, args, gestureKey).bind(bindFunction);
        }
      }
      const nativeBindFunction = bindToProps(props, sharedConfig.eventOptions, !!target);
      for (const eventKey in this.nativeHandlers) {
        nativeBindFunction(eventKey, "", (event) => this.nativeHandlers[eventKey](_objectSpread2(_objectSpread2({}, this.state.shared), {}, {
          event,
          args
        })), void 0, true);
      }
    }
    for (const handlerProp in props) {
      props[handlerProp] = chain(...props[handlerProp]);
    }
    if (!target) return props;
    for (const handlerProp in props) {
      const {
        device,
        capture,
        passive
      } = parseProp(handlerProp);
      this._targetEventStore.add(target, device, "", props[handlerProp], {
        capture,
        passive
      });
    }
  }
};
function setupGesture(ctrl, gestureKey) {
  ctrl.gestures.add(gestureKey);
  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl, gestureKey);
  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();
}
function resolveGestures(ctrl, internalHandlers) {
  if (internalHandlers.drag) setupGesture(ctrl, "drag");
  if (internalHandlers.wheel) setupGesture(ctrl, "wheel");
  if (internalHandlers.scroll) setupGesture(ctrl, "scroll");
  if (internalHandlers.move) setupGesture(ctrl, "move");
  if (internalHandlers.pinch) setupGesture(ctrl, "pinch");
  if (internalHandlers.hover) setupGesture(ctrl, "hover");
}
var bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options = {}, isNative = false) => {
  var _options$capture, _options$passive;
  const capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;
  const passive = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;
  let handlerProp = isNative ? device : toHandlerProp(device, action, capture);
  if (withPassiveOption && passive) handlerProp += "Passive";
  props[handlerProp] = props[handlerProp] || [];
  props[handlerProp].push(handler);
};
var RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;
function sortHandlers(_handlers) {
  const native = {};
  const handlers = {};
  const actions = /* @__PURE__ */ new Set();
  for (let key in _handlers) {
    if (RE_NOT_NATIVE.test(key)) {
      actions.add(RegExp.lastMatch);
      handlers[key] = _handlers[key];
    } else {
      native[key] = _handlers[key];
    }
  }
  return [handlers, native, actions];
}
function registerGesture(actions, handlers, handlerKey, key, internalHandlers, config) {
  if (!actions.has(handlerKey)) return;
  if (!EngineMap.has(key)) {
    if (true) {
      console.warn(`[@use-gesture]: You've created a custom handler that that uses the \`${key}\` gesture but isn't properly configured.

Please add \`${key}Action\` when creating your handler.`);
    }
    return;
  }
  const startKey = handlerKey + "Start";
  const endKey = handlerKey + "End";
  const fn = (state) => {
    let memo = void 0;
    if (state.first && startKey in handlers) handlers[startKey](state);
    if (handlerKey in handlers) memo = handlers[handlerKey](state);
    if (state.last && endKey in handlers) handlers[endKey](state);
    return memo;
  };
  internalHandlers[key] = fn;
  config[key] = config[key] || {};
}
function parseMergedHandlers(mergedHandlers, mergedConfig) {
  const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers);
  const internalHandlers = {};
  registerGesture(actions, handlers, "onDrag", "drag", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onWheel", "wheel", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onScroll", "scroll", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onPinch", "pinch", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onMove", "move", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onHover", "hover", internalHandlers, mergedConfig);
  return {
    handlers: internalHandlers,
    config: mergedConfig,
    nativeHandlers
  };
}

// node_modules/@use-gesture/react/dist/use-gesture-react.esm.js
function useRecognizers(handlers, config = {}, gestureKey, nativeHandlers) {
  const ctrl = import_react2.default.useMemo(() => new Controller(handlers), []);
  ctrl.applyHandlers(handlers, nativeHandlers);
  ctrl.applyConfig(config, gestureKey);
  import_react2.default.useEffect(ctrl.effect.bind(ctrl));
  import_react2.default.useEffect(() => {
    return ctrl.clean.bind(ctrl);
  }, []);
  if (config.target === void 0) {
    return ctrl.bind.bind(ctrl);
  }
  return void 0;
}
function useDrag(handler, config) {
  registerAction(dragAction);
  return useRecognizers({
    drag: handler
  }, config || {}, "drag");
}
function createUseGesture(actions) {
  actions.forEach(registerAction);
  return function useGesture2(_handlers, _config) {
    const {
      handlers,
      nativeHandlers,
      config
    } = parseMergedHandlers(_handlers, _config || {});
    return useRecognizers(handlers, config, void 0, nativeHandlers);
  };
}
function useGesture(handlers, config) {
  const hook = createUseGesture([dragAction, pinchAction, scrollAction, wheelAction, moveAction, hoverAction]);
  return hook(handlers, config || {});
}

// node_modules/mafs/build/index.mjs
var React3 = __toESM(require_react(), 1);
var React4 = __toESM(require_react(), 1);
var React5 = __toESM(require_react(), 1);
var React6 = __toESM(require_react(), 1);
var React7 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var React10 = __toESM(require_react(), 1);
var React9 = __toESM(require_react(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var React11 = __toESM(require_react(), 1);
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var React12 = __toESM(require_react(), 1);
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
var React13 = __toESM(require_react(), 1);
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
var React14 = __toESM(require_react(), 1);
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
var React15 = __toESM(require_react(), 1);
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
var CoordinateContext = React2.createContext(null);
CoordinateContext.displayName = "CoordinateContext";
function useCoordinateContext() {
  const context = React2.useContext(CoordinateContext);
  invariant(
    context,
    "CoordinateContext is not loaded. Are you rendering a Mafs component outside of Mafs?"
  );
  return context;
}
var CoordinateContext_default = CoordinateContext;
function round(value, precision = 0) {
  const multiplier = Math.pow(10, precision || 0);
  return Math.round(value * multiplier) / multiplier;
}
function range(min, max, step = 1) {
  const result = [];
  for (let i = min; i < max - step / 2; i += step) {
    result.push(i);
  }
  const computedMax = result[result.length - 1] + step;
  if (Math.abs(max - computedMax) < step / 1e-6) {
    result.push(max);
  } else {
    result.push(computedMax);
  }
  return result;
}
function clamp2(number, min, max) {
  return Math.min(Math.max(number, min), max);
}
var { round: round2, ceil, floor, log2 } = Math;
var PaneContext = React22.createContext({
  xPanes: [],
  yPanes: [],
  xPaneRange: [0, 0],
  yPaneRange: [0, 0]
});
PaneContext.displayName = "PaneContext";
function usePaneContext() {
  return React22.useContext(PaneContext);
}
function PaneManager({ children }) {
  const { xMin, xMax, yMin, yMax } = useCoordinateContext();
  const xPaneSize = 2 ** round2(log2(xMax - xMin) - 1);
  const yPaneSize = 2 ** round2(log2(yMax - yMin) - 1);
  const pad = 1 / 8;
  const xLowerBound = xPaneSize * floor(xMin / xPaneSize - pad);
  const xUpperBound = xPaneSize * ceil(xMax / xPaneSize + pad);
  const yLowerBound = yPaneSize * floor(yMin / yPaneSize - pad);
  const yUpperBound = yPaneSize * ceil(yMax / yPaneSize + pad);
  const xPanes = React22.useMemo(
    () => range(xLowerBound, xUpperBound - xPaneSize, xPaneSize).map(
      (xMin2) => [xMin2, xMin2 + xPaneSize]
    ),
    [xLowerBound, xUpperBound, xPaneSize]
  );
  const yPanes = React22.useMemo(
    () => range(yLowerBound, yUpperBound - yPaneSize, yPaneSize).map(
      (yMin2) => [yMin2, yMin2 + yPaneSize]
    ),
    [yLowerBound, yUpperBound, yPaneSize]
  );
  const context = React22.useMemo(
    () => ({
      xPanes,
      yPanes,
      xPaneRange: [xLowerBound, xUpperBound],
      yPaneRange: [yLowerBound, yUpperBound]
    }),
    [xPanes, yPanes, xLowerBound, xUpperBound, yLowerBound, yUpperBound]
  );
  return (0, import_jsx_runtime.jsx)(PaneContext.Provider, { value: context, children });
}
PaneManager.displayName = "PaneManager";
var PaneContext_default = PaneManager;
var vec;
((vec2) => {
  function add(v, v2) {
    return [v[0] + v2[0], v[1] + v2[1]];
  }
  vec2.add = add;
  function sub(v, v2) {
    return [v[0] - v2[0], v[1] - v2[1]];
  }
  vec2.sub = sub;
  function mag(v) {
    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
  }
  vec2.mag = mag;
  function normal(v) {
    return [-v[1], v[0]];
  }
  vec2.normal = normal;
  function lerp(v1, v2, t) {
    const d = sub(v2, v1);
    const m = mag(d);
    return add(v1, withMag(d, t * m));
  }
  vec2.lerp = lerp;
  function withMag(v, m) {
    const magnitude = mag(v);
    return scale(v, m / magnitude);
  }
  vec2.withMag = withMag;
  function normalize(v) {
    return withMag(v, 1);
  }
  vec2.normalize = normalize;
  function scale(v, sc) {
    return [v[0] * sc, v[1] * sc];
  }
  vec2.scale = scale;
  function transform(v, m) {
    return [v[0] * m[0] + v[1] * m[1] + m[2], v[0] * m[3] + v[1] * m[4] + m[5]];
  }
  vec2.transform = transform;
  function matrixMult(m, m2) {
    return matrixCreate(
      m[0] * m2[0] + m[1] * m2[3],
      m[3] * m2[0] + m[4] * m2[3],
      m[0] * m2[1] + m[1] * m2[4],
      m[3] * m2[1] + m[4] * m2[4],
      m[0] * m2[2] + m[1] * m2[5] + m[2],
      m[3] * m2[2] + m[4] * m2[5] + m[5]
    );
  }
  vec2.matrixMult = matrixMult;
  function rotate(v, a) {
    const c = Math.cos(a);
    const s = Math.sin(a);
    return [v[0] * c - v[1] * s, v[0] * s + v[1] * c];
  }
  vec2.rotate = rotate;
  function rotateAbout(v, cp, a) {
    const v2 = sub(v, cp);
    return add(cp, rotate(v2, a));
  }
  vec2.rotateAbout = rotateAbout;
  function midpoint(v, v2) {
    return lerp(v, v2, 0.5);
  }
  vec2.midpoint = midpoint;
  function dist(v, v2) {
    return Math.sqrt(squareDist(v, v2));
  }
  vec2.dist = dist;
  function squareDist(v, v2) {
    return Math.pow(v2[0] - v[0], 2) + Math.pow(v2[1] - v[1], 2);
  }
  vec2.squareDist = squareDist;
  function dot(v, v2) {
    return v[0] * v2[0] + v[1] * v2[1];
  }
  vec2.dot = dot;
  function det(m) {
    return m[0] * m[4] - m[3] * m[1];
  }
  vec2.det = det;
  function matrixInvert(a) {
    const mDet = det(a);
    if (!mDet)
      return null;
    const invDet = 1 / mDet;
    const a00 = a[0], a01 = a[1], a02 = a[2];
    const a10 = a[3], a11 = a[4], a12 = a[5];
    return matrixCreate(
      invDet * a11,
      invDet * -a10,
      invDet * -a01,
      invDet * a00,
      invDet * (a12 * a01 - a02 * a11),
      invDet * (-a12 * a00 + a02 * a10)
    );
  }
  vec2.matrixInvert = matrixInvert;
  function matrixBuilder(m = null) {
    const _m = m || matrixCreate();
    return {
      mult: (m2) => matrixBuilder(matrixMult(m2, _m)),
      translate: (x, y) => matrixBuilder(matrixMult(matrixCreate(1, 0, 0, 1, x, y), _m)),
      rotate: (a) => {
        const c = Math.cos(a);
        const s = Math.sin(a);
        return matrixBuilder(matrixMult(matrixCreate(c, s, -s, c), _m));
      },
      scale: (x, y) => matrixBuilder(matrixMult(matrixCreate(x, 0, 0, y), _m)),
      shear: (x, y) => matrixBuilder(matrixMult(matrixCreate(1, y, x, 1), _m)),
      get: () => [..._m]
    };
  }
  vec2.matrixBuilder = matrixBuilder;
  function toCSS(matrix) {
    const [a, c, tx, b, d, ty] = matrix;
    return `matrix(${a}, ${b}, ${c}, ${d}, ${tx}, ${ty})`;
  }
  vec2.toCSS = toCSS;
  vec2.identity = matrixBuilder().get();
})(vec || (vec = {}));
function matrixCreate(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {
  return [a, c, tx, b, d, ty];
}
var TransformContext = React3.createContext(null);
TransformContext.displayName = "TransformContext";
function useTransformContext() {
  const context = React3.useContext(TransformContext);
  invariant(
    context,
    "TransformContext is not loaded. Are you rendering a Mafs component outside of a MafsView?"
  );
  return context;
}
var SpanContext = React4.createContext({
  xSpan: 0,
  ySpan: 0
});
SpanContext.displayName = "SpanContext";
function useSpanContext() {
  const context = React4.useContext(SpanContext);
  invariant(context, "SpanContext is not defined");
  return context;
}
function useCamera({ minZoom, maxZoom }) {
  const [matrix, setMatrix] = React5.useState(vec.identity);
  const initialMatrix = React5.useRef(vec.identity);
  return {
    matrix,
    setBase() {
      initialMatrix.current = matrix;
    },
    move({ zoom, pan }) {
      const scale = 1 / ((zoom == null ? void 0 : zoom.scale) ?? 1);
      const zoomAt = (zoom == null ? void 0 : zoom.at) ?? [0, 0];
      const currentScale = initialMatrix.current[0];
      const minScale = 1 / maxZoom / currentScale;
      const maxScale = 1 / minZoom / currentScale;
      const clampedScale = clamp2(scale, minScale, maxScale);
      const newCamera = vec.matrixBuilder(initialMatrix.current).translate(...vec.scale(zoomAt, -1)).scale(clampedScale, clampedScale).translate(...vec.scale(zoomAt, 1)).translate(...pan ?? [0, 0]).get();
      setMatrix(newCamera);
    }
  };
}
function useWheelEnabler(zoomEnabled) {
  const [wheelEnabled, setWheelEnabled] = React6.useState(false);
  const timer = React6.useRef(0);
  React6.useEffect(() => {
    if (!zoomEnabled)
      return;
    function handleWindowScroll() {
      setWheelEnabled(false);
      clearTimeout(timer.current);
      timer.current = setTimeout(() => {
        setWheelEnabled(true);
      }, 500);
    }
    window.addEventListener("scroll", handleWindowScroll);
    return () => window.removeEventListener("scroll", handleWindowScroll);
  }, [zoomEnabled]);
  return {
    wheelEnabled: zoomEnabled ? wheelEnabled : false,
    handleMouseMove() {
      setWheelEnabled(true);
    }
  };
}
var TestContext = React7.createContext({
  overrideHeight: void 0
});
var TestContextProvider = TestContext.Provider;
function Mafs({
  width: propWidth = "auto",
  height: propHeight = 500,
  pan = true,
  zoom = false,
  viewBox = { x: [-3, 3], y: [-3, 3] },
  preserveAspectRatio = "contain",
  children,
  ssr = false,
  onClick = void 0
}) {
  const testContext = React8.useContext(TestContext);
  const height = testContext.overrideHeight ?? propHeight;
  const desiredCssWidth = propWidth === "auto" ? "100%" : `${propWidth}px`;
  const rootRef = React8.useRef(null);
  const { width = propWidth === "auto" ? ssr ? 500 : 0 : propWidth } = useResizeObserver({
    ref: propWidth === "auto" ? rootRef : null
  });
  return (0, import_jsx_runtime2.jsx)(
    "div",
    {
      className: "MafsView",
      style: { width: desiredCssWidth, height },
      tabIndex: pan || zoom ? 0 : -1,
      ref: rootRef,
      children: width > 0 && (0, import_jsx_runtime2.jsx)(
        MafsCanvas,
        {
          width,
          height,
          desiredCssWidth,
          rootRef,
          pan,
          zoom,
          viewBox,
          preserveAspectRatio,
          ssr,
          onClick,
          children
        }
      )
    }
  );
}
function MafsCanvas({
  width,
  height,
  desiredCssWidth,
  rootRef,
  pan,
  zoom,
  viewBox,
  preserveAspectRatio,
  children,
  onClick
}) {
  var _a, _b, _c, _d;
  let minZoom = 1;
  let maxZoom = 1;
  if (typeof zoom === "object") {
    invariant(zoom.min > 0 && zoom.min <= 1, "zoom.min must be in the range (0, 1]");
    invariant(zoom.max >= 1, "zoom.max must be in the range [1, )");
    minZoom = zoom.min;
    maxZoom = zoom.max;
  } else if (zoom) {
    minZoom = 0.5;
    maxZoom = 5;
  }
  const camera = useCamera({ minZoom, maxZoom });
  const padding = (viewBox == null ? void 0 : viewBox.padding) ?? 0.5;
  let xMin = (((_a = viewBox == null ? void 0 : viewBox.x) == null ? void 0 : _a[0]) ?? 0) - padding;
  let xMax = (((_b = viewBox == null ? void 0 : viewBox.x) == null ? void 0 : _b[1]) ?? 0) + padding;
  let yMin = (((_c = viewBox == null ? void 0 : viewBox.y) == null ? void 0 : _c[0]) ?? 0) - padding;
  let yMax = (((_d = viewBox == null ? void 0 : viewBox.y) == null ? void 0 : _d[1]) ?? 0) + padding;
  if (preserveAspectRatio === "contain") {
    const aspect = width / height;
    const aoiAspect = (xMax - xMin) / (yMax - yMin);
    if (aoiAspect > aspect) {
      const yCenter = (yMax + yMin) / 2;
      const ySpan2 = (xMax - xMin) / aspect / 2;
      yMin = yCenter - ySpan2;
      yMax = yCenter + ySpan2;
    } else {
      const xCenter = (xMax + xMin) / 2;
      const xSpan2 = (yMax - yMin) * aspect / 2;
      xMin = xCenter - xSpan2;
      xMax = xCenter + xSpan2;
    }
  }
  ;
  [xMin, yMin] = vec.transform([xMin, yMin], camera.matrix);
  [xMax, yMax] = vec.transform([xMax, yMax], camera.matrix);
  const xSpan = xMax - xMin;
  const ySpan = yMax - yMin;
  const viewTransform = React8.useMemo(() => {
    const scaleX = round(1 / xSpan * width, 5);
    const scaleY = round(-1 / ySpan * height, 5);
    return vec.matrixBuilder().scale(scaleX, scaleY).get();
  }, [height, width, xSpan, ySpan]);
  const viewBoxX = round(xMin / (xMax - xMin) * width, 10);
  const viewBoxY = round(yMax / (yMin - yMax) * height, 10);
  const inverseViewTransform = vec.matrixInvert(viewTransform);
  const pickupOrigin = React8.useRef([0, 0]);
  const pickupPoint = React8.useRef([0, 0]);
  function mapGesturePoint(point) {
    const el = rootRef.current;
    invariant(el, "SVG is not mounted");
    invariant(inverseViewTransform, "View transform is not invertible");
    const rect = el.getBoundingClientRect();
    return vec.transform(
      [point[0] - rect.left + viewBoxX, point[1] - rect.top + viewBoxY],
      inverseViewTransform
    );
  }
  const wheelEnabler = useWheelEnabler(!!zoom);
  const justDragged = React8.useRef(false);
  useGesture(
    {
      onDrag: ({ movement, first, event, type, pinching, memo = [0, 0], last }) => {
        if (pinching)
          return movement;
        if (first)
          camera.setBase();
        const [mx, my] = vec.sub(movement, memo);
        camera.move({ pan: [-mx / width * xSpan, my / height * ySpan] });
        const keyboard = type.includes("key");
        if (keyboard)
          event == null ? void 0 : event.preventDefault();
        if (last) {
          justDragged.current = true;
          setTimeout(() => justDragged.current = false, 10);
        }
        return !keyboard && first ? movement : memo;
      },
      onPinch: ({ first, movement: [scale], origin, event, last }) => {
        if (!event.currentTarget || !inverseViewTransform)
          return;
        if (first) {
          camera.setBase();
          pickupOrigin.current = origin;
          pickupPoint.current = pan ? mapGesturePoint(origin) : [(xMin + xMax) / 2, (yMin + yMax) / 2];
        }
        let offset = [0, 0];
        if (pan) {
          offset = vec.transform(vec.sub(origin, pickupOrigin.current), inverseViewTransform);
        }
        camera.move({ zoom: { at: pickupPoint.current, scale }, pan: vec.scale(offset, -1) });
        if (last)
          camera.setBase();
      },
      onWheel: ({ pinching, event, delta: [, scroll] }) => {
        if (pinching)
          return;
        const scale = 2 / (1 + Math.exp(-scroll / 300));
        const point = mapGesturePoint([event.clientX, event.clientY]);
        camera.setBase();
        camera.move({ zoom: { at: point, scale: 1 / scale } });
      },
      onKeyDown: ({ event }) => {
        if (event.metaKey)
          return;
        const base = { Equal: 1, Minus: -1 }[event.code] ?? 0;
        if (!base)
          return;
        let multiplier = 0.1;
        if (event.altKey || event.metaKey)
          multiplier = 0.01;
        if (event.shiftKey)
          multiplier = 0.3;
        const scale = 1 + base * multiplier;
        const center = [(xMax + xMin) / 2, (yMax + yMin) / 2];
        camera.setBase();
        camera.move({ zoom: { at: center, scale } });
      },
      onMouseMove: () => {
        wheelEnabler.handleMouseMove();
      },
      onClick: ({ event }) => {
        if (!onClick || !rootRef.current || justDragged.current)
          return;
        const box = rootRef.current.getBoundingClientRect();
        const pxX = event.clientX - box.left;
        const pxY = box.bottom - event.clientY;
        const x = pxX / width * xSpan + xMin;
        const y = pxY / height * ySpan + yMin;
        onClick([x, y], event);
      }
    },
    {
      drag: { enabled: pan, eventOptions: { passive: false }, threshold: 1 },
      pinch: { enabled: !!zoom, eventOptions: { passive: false } },
      wheel: {
        enabled: wheelEnabler.wheelEnabled,
        preventDefault: true,
        eventOptions: { passive: false }
      },
      target: rootRef
    }
  );
  const viewTransformCSS = vec.toCSS(viewTransform);
  const coordinateContext = React8.useMemo(
    () => ({ xMin, xMax, yMin, yMax, height, width }),
    [xMin, xMax, yMin, yMax, height, width]
  );
  return (0, import_jsx_runtime2.jsx)(CoordinateContext_default.Provider, { value: coordinateContext, children: (0, import_jsx_runtime2.jsx)(SpanContext.Provider, { value: { xSpan, ySpan }, children: (0, import_jsx_runtime2.jsx)(
    TransformContext.Provider,
    {
      value: { userTransform: vec.identity, viewTransform },
      children: (0, import_jsx_runtime2.jsx)(PaneContext_default, { children: (0, import_jsx_runtime2.jsx)(
        "svg",
        {
          width,
          height,
          viewBox: `${viewBoxX} ${viewBoxY} ${width} ${height}`,
          preserveAspectRatio: "xMidYMin",
          style: {
            width: desiredCssWidth,
            touchAction: pan ? "none" : "auto",
            ...{
              "--mafs-view-transform": viewTransformCSS,
              "--mafs-user-transform": "translate(0, 0)"
            }
          },
          children
        }
      ) })
    }
  ) }) });
}
Mafs.displayName = "Mafs";
var defaultLabelMaker = (x) => (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [
  x,
  x < 0 && (0, import_jsx_runtime3.jsx)("tspan", { visibility: "hidden", children: "-" })
] });
var defaultAxisOptions = {
  axis: true,
  lines: 1,
  labels: defaultLabelMaker
};
function XLabels({ separation, labelMaker }) {
  const { viewTransform } = useTransformContext();
  const { xPanes } = usePaneContext();
  return (0, import_jsx_runtime3.jsx)("g", { className: "mafs-axis", children: xPanes.map(([min, max]) => (0, import_jsx_runtime3.jsx)("g", { children: snappedRange(min, max, separation).filter((x) => Math.abs(x) > separation / 1e6).map((x) => (0, import_jsx_runtime3.jsx)(
    "text",
    {
      x: vec.transform([x, 0], viewTransform)[0],
      y: 5,
      dominantBaseline: "hanging",
      textAnchor: "middle",
      style: { fill: "var(--mafs-origin-color)", paintOrder: "stroke" },
      children: labelMaker(x)
    },
    x
  )) }, `${min},${max}`)) });
}
XLabels.displayName = "CartesianCoordinates.XLabels";
function YLabels({ separation, labelMaker }) {
  const { viewTransform } = useTransformContext();
  const { yPanes } = usePaneContext();
  return (0, import_jsx_runtime3.jsx)("g", { className: "mafs-axis", children: yPanes.map(([min, max]) => (0, import_jsx_runtime3.jsx)("g", { children: snappedRange(min, max, separation).filter((y) => Math.abs(y) > separation / 1e6).map((y) => (0, import_jsx_runtime3.jsx)(
    "text",
    {
      x: 5,
      y: vec.transform([0, y], viewTransform)[1],
      dominantBaseline: "central",
      style: { fill: "var(--mafs-origin-color)", paintOrder: "stroke" },
      children: labelMaker(y)
    },
    y
  )) }, `${min},${max}`)) });
}
YLabels.displayName = "CartesianCoordinates.YLabels";
var incrementer = 0;
function Cartesian({
  xAxis: xAxisOverrides,
  yAxis: yAxisOverrides,
  subdivisions = false
}) {
  const xAxisEnabled = xAxisOverrides !== false;
  const yAxisEnabled = yAxisOverrides !== false;
  const xAxis = { subdivisions, ...defaultAxisOptions, ...xAxisOverrides };
  const yAxis = { subdivisions, ...defaultAxisOptions, ...yAxisOverrides };
  const id = `cartesian-${incrementer++}`;
  const { viewTransform } = useTransformContext();
  const { xPaneRange, yPaneRange } = usePaneContext();
  const [xMin, xMax] = xPaneRange;
  const [yMin, yMax] = yPaneRange;
  const [vxMin, vyMin] = vec.transform([xMin, yMin], viewTransform);
  const [vxMax, vyMax] = vec.transform([xMax, yMax], viewTransform);
  const xLines = xAxis.lines || 1;
  const yLines = yAxis.lines || 1;
  const [unitW, unitH] = vec.transform([xLines, -yLines], viewTransform);
  const xSubs = xAxis.subdivisions || 1;
  const ySubs = yAxis.subdivisions || 1;
  const subUnitW = unitW / xSubs;
  const subUnitH = unitH / ySubs;
  return (0, import_jsx_runtime4.jsxs)("g", { fill: "none", children: [
    (0, import_jsx_runtime4.jsxs)("pattern", { x: 0, y: 0, width: unitW, height: unitH, id, patternUnits: "userSpaceOnUse", children: [
      (0, import_jsx_runtime4.jsx)(
        "pattern",
        {
          width: subUnitW,
          height: subUnitH,
          id: `${id}-subdivision`,
          patternUnits: "userSpaceOnUse",
          children: (0, import_jsx_runtime4.jsxs)("g", { stroke: "var(--grid-line-subdivision-color)", children: [
            xAxisEnabled !== false && xSubs > 1 && (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
              (0, import_jsx_runtime4.jsx)("line", { x1: 0, y1: 0, x2: 0, y2: subUnitH }),
              (0, import_jsx_runtime4.jsx)("line", { x1: subUnitW, y1: 0, x2: subUnitW, y2: subUnitH })
            ] }),
            yAxisEnabled !== false && ySubs > 1 && (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
              (0, import_jsx_runtime4.jsx)("line", { x1: 0, y1: 0, x2: subUnitW, y2: 0 }),
              (0, import_jsx_runtime4.jsx)("line", { x1: 0, y1: subUnitH, x2: subUnitW, y2: subUnitH })
            ] })
          ] })
        }
      ),
      (0, import_jsx_runtime4.jsx)("rect", { width: unitW, height: unitH, fill: `url(#${id}-subdivision)` }),
      (0, import_jsx_runtime4.jsxs)("g", { stroke: "var(--mafs-line-color)", children: [
        yAxisEnabled && xAxis.lines && (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
          (0, import_jsx_runtime4.jsx)("line", { x1: 0, y1: 0, x2: unitW, y2: 0 }),
          (0, import_jsx_runtime4.jsx)("line", { x1: 0, y1: unitH, x2: unitW, y2: unitH })
        ] }),
        xAxisEnabled && yAxis.lines && (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
          (0, import_jsx_runtime4.jsx)("line", { x1: 0, y1: 0, x2: 0, y2: unitH }),
          (0, import_jsx_runtime4.jsx)("line", { x1: unitW, y1: 0, x2: unitW, y2: unitH })
        ] })
      ] })
    ] }),
    (0, import_jsx_runtime4.jsx)("rect", { x: vxMin, y: vyMax, width: vxMax - vxMin, height: vyMin - vyMax, fill: `url(#${id})` }),
    (0, import_jsx_runtime4.jsxs)("g", { stroke: "var(--mafs-origin-color)", children: [
      xAxisEnabled && xAxis.axis && (0, import_jsx_runtime4.jsx)("line", { x1: vxMin, y1: 0, x2: vxMax, y2: 0 }),
      yAxisEnabled && yAxis.axis && (0, import_jsx_runtime4.jsx)("line", { x1: 0, y1: vyMin, x2: 0, y2: vyMax })
    ] }),
    (0, import_jsx_runtime4.jsxs)("g", { className: "mafs-shadow", children: [
      xAxisEnabled && xAxis.labels && (0, import_jsx_runtime4.jsx)(XLabels, { separation: xAxis.lines || 1, labelMaker: xAxis.labels }),
      yAxisEnabled && yAxis.labels && (0, import_jsx_runtime4.jsx)(YLabels, { separation: yAxis.lines || 1, labelMaker: yAxis.labels })
    ] })
  ] });
}
function snappedRange(min, max, step) {
  const roundMin = Math.floor(min / step) * step;
  const roundMax = Math.ceil(max / step) * step;
  if (roundMin === roundMax - step)
    return [roundMin];
  return range(roundMin, roundMax - step, step);
}
function autoPi(x) {
  if (x === 0)
    return "0";
  if (Math.abs(Math.PI - x) < 1e-3)
    return "";
  if (Math.abs(-Math.PI - x) < 1e-3)
    return "-";
  return `${round(x / Math.PI, 5)}`;
}
var thetas = range(0, 2 * Math.PI, Math.PI / 12);
function PolarCoordinates({
  xAxis: xAxisOverrides,
  yAxis: yAxisOverrides,
  lines = 1,
  subdivisions
}) {
  const xAxisEnabled = xAxisOverrides !== false;
  const yAxisEnabled = yAxisOverrides !== false;
  const xAxis = { ...defaultAxisOptions, ...xAxisOverrides };
  const yAxis = { ...defaultAxisOptions, ...yAxisOverrides };
  const { viewTransform } = useTransformContext();
  const { xPaneRange, yPaneRange } = usePaneContext();
  const [xMin, xMax] = xPaneRange;
  const [yMin, yMax] = yPaneRange;
  const distances = [
    vec.mag([xMin, yMin]),
    vec.mag([xMin, yMax]),
    vec.mag([xMax, yMin]),
    vec.mag([xMax, yMax]),
    vec.mag([(xMin + xMax) / 2, (yMin + yMax) / 2])
  ];
  const b = lines;
  const closeToOrigin = Math.min(...distances) < Math.max(xMax - xMin, yMax - yMin);
  const minRadiusPrecise = closeToOrigin ? 0 : Math.min(...distances);
  const maxRadiusPrecise = Math.max(...distances);
  const minRadius = Math.floor(minRadiusPrecise / b) * b;
  const maxRadius = Math.ceil(maxRadiusPrecise / b) * b;
  const [vxMin, vyMin] = vec.transform([xMin, yMin], viewTransform);
  const [vxMax, vyMax] = vec.transform([xMax, yMax], viewTransform);
  const [scaleX, scaleY] = vec.transform([1, -1], viewTransform);
  const rs = range(minRadius, maxRadius, b);
  const subRs = subdivisions != void 0 ? range(minRadius, maxRadius, b / subdivisions) : [];
  return (0, import_jsx_runtime5.jsxs)("g", { fill: "none", children: [
    (0, import_jsx_runtime5.jsx)("g", { stroke: "var(--grid-line-subdivision-color)", children: thetas.map((theta) => (0, import_jsx_runtime5.jsx)(
      "line",
      {
        x1: 0,
        y1: 0,
        x2: Math.cos(theta) * maxRadius * scaleX,
        y2: -Math.sin(theta) * maxRadius * scaleY
      },
      theta
    )) }),
    subRs.map((r) => (0, import_jsx_runtime5.jsx)(
      "ellipse",
      {
        "data-r": r,
        cx: 0,
        cy: 0,
        rx: r * scaleX,
        ry: r * scaleY,
        stroke: "var(--grid-line-subdivision-color)"
      },
      r
    )),
    rs.map((r) => (0, import_jsx_runtime5.jsx)(
      "ellipse",
      {
        "data-r": r,
        cx: 0,
        cy: 0,
        rx: r * scaleX,
        ry: r * scaleY,
        stroke: "var(--mafs-line-color)"
      },
      r
    )),
    (0, import_jsx_runtime5.jsxs)("g", { stroke: "var(--mafs-origin-color)", children: [
      xAxisEnabled && xAxis.axis && (0, import_jsx_runtime5.jsx)("line", { x1: vxMin, y1: 0, x2: vxMax, y2: 0 }),
      yAxisEnabled && yAxis.axis && (0, import_jsx_runtime5.jsx)("line", { x1: 0, y1: vyMin, x2: 0, y2: vyMax })
    ] }),
    (0, import_jsx_runtime5.jsxs)("g", { className: "mafs-shadow", children: [
      xAxisEnabled && xAxis.labels && (0, import_jsx_runtime5.jsx)(
        XLabels,
        {
          separation: (xAxisOverrides == null ? void 0 : xAxisOverrides.lines) || lines || 1,
          labelMaker: xAxis.labels || defaultLabelMaker
        }
      ),
      yAxisEnabled && yAxis.labels && (0, import_jsx_runtime5.jsx)(
        YLabels,
        {
          separation: (yAxisOverrides == null ? void 0 : yAxisOverrides.lines) || lines || 1,
          labelMaker: yAxis.labels || defaultLabelMaker
        }
      )
    ] })
  ] });
}
PolarCoordinates.displayName = "Coordinates.Polar";
Cartesian.displayName = "Coordinates.Cartesian";
var Coordinates = {
  Cartesian,
  Polar: PolarCoordinates
};
function sample({
  domain,
  minDepth,
  maxDepth,
  threshold,
  fn,
  error,
  onPoint,
  midpoint
}) {
  const [min, max] = domain;
  function subdivide(min2, max2, pushLeft, pushRight, depth, pMin, pMax) {
    const t = 0.5;
    const mid = min2 + (max2 - min2) * t;
    const pMid = fn(mid);
    if (depth < minDepth) {
      subdivide(min2, mid, true, false, depth + 1, pMin, pMid);
      subdivide(mid, max2, false, true, depth + 1, pMid, pMax);
      return;
    }
    if (depth < maxDepth) {
      const fnMidpoint = midpoint(pMin, pMax);
      const e = error(pMid, fnMidpoint);
      if (e > threshold) {
        subdivide(min2, mid, true, false, depth + 1, pMin, pMid);
        subdivide(mid, max2, false, true, depth + 1, pMid, pMax);
        return;
      }
    }
    if (pushLeft) {
      onPoint(min2, pMin);
    }
    onPoint(mid, pMid);
    if (pushRight) {
      onPoint(max2, pMax);
    }
  }
  subdivide(min, max, true, true, 0, fn(min), fn(max));
}
function sampleParametric(fn, domain, minDepth, maxDepth, threshold) {
  let result = "M ";
  sample({
    fn,
    error: (a, b) => vec.squareDist(a, b),
    onPoint: (_t, [x, y]) => {
      if (Number.isFinite(x) && Number.isFinite(y)) {
        result += `${x} ${y} L `;
      }
    },
    midpoint: (p1, p2) => vec.midpoint(p1, p2),
    domain,
    minDepth,
    maxDepth,
    threshold
  });
  return result.substring(0, result.length - 2);
}
function sampleInequality(rangeAxis, upper, lower, domain, minDepth, maxDepth, threshold) {
  const result = { fill: "", upper: "", lower: "" };
  let upperTmp = "";
  let lowerTmp = "";
  let ineqFalse = false;
  let prevX = 0;
  let prevUpper = 0;
  let prevLower = 0;
  function pointToString(x, y) {
    return rangeAxis === "x" ? `${x} ${y}` : `${y} ${x}`;
  }
  sample({
    domain,
    minDepth,
    maxDepth,
    threshold,
    fn: (x) => [
      [x, lower(x)],
      [x, upper(x)]
    ],
    error: ([realLower, realUpper], [estLower, estUpper]) => {
      return Math.max(vec.squareDist(realLower, estLower), vec.squareDist(realUpper, estUpper));
    },
    midpoint: ([aLower, aUpper], [bLower, bUpper]) => {
      return [vec.midpoint(aLower, bLower), vec.midpoint(aUpper, bUpper)];
    },
    onPoint: (x, [[, lower2], [, upper2]]) => {
      const pathsJustCrossed = upper2 < lower2 && !ineqFalse;
      const pathsJustUncrossed = upper2 > lower2 && ineqFalse;
      if (pathsJustCrossed) {
        ineqFalse = true;
        if (upperTmp && lowerTmp) {
          const midX = (prevX + x) / 2;
          const midUpper = (prevUpper + upper2) / 2;
          const midLower = (prevLower + lower2) / 2;
          const midY = (midUpper + midLower) / 2;
          upperTmp += ` ${pointToString(midX, midY)} L `;
          lowerTmp = ` ${pointToString(midX, midY)} L ` + lowerTmp;
          result.fill += ` M ${upperTmp} ${lowerTmp.substring(0, lowerTmp.length - 2)} z `;
          result.upper += ` M ${upperTmp.substring(0, upperTmp.length - 2)} `;
          result.lower += ` M ${lowerTmp.substring(0, lowerTmp.length - 2)} `;
          upperTmp = "";
          lowerTmp = "";
        }
      } else if (pathsJustUncrossed) {
        ineqFalse = false;
        const midX = (prevX + x) / 2;
        const midUpper = (prevUpper + upper2) / 2;
        const midLower = (prevLower + lower2) / 2;
        const midY = (midUpper + midLower) / 2;
        upperTmp += ` ${pointToString(midX, midY)} L `;
        lowerTmp = ` ${pointToString(midX, midY)} L ` + lowerTmp;
      }
      if (!ineqFalse) {
        if (Number.isFinite(upper2)) {
          upperTmp = upperTmp + ` ${pointToString(x, upper2)} L `;
        }
        if (Number.isFinite(lower2)) {
          lowerTmp = ` ${pointToString(x, lower2)} L ` + lowerTmp;
        }
      }
      prevX = x;
      prevUpper = upper2;
      prevLower = lower2;
    }
  });
  if (upperTmp && lowerTmp) {
    result.fill += ` M ${upperTmp} ${lowerTmp.substring(0, lowerTmp.length - 2)} z `;
    result.lower += ` M ${lowerTmp.substring(0, lowerTmp.length - 2)} `;
    result.upper += ` M ${upperTmp.substring(0, upperTmp.length - 2)} `;
  }
  return result;
}
function Parametric({
  xy,
  t,
  color,
  style = "solid",
  weight = 2,
  opacity = 1,
  maxSamplingDepth = 14,
  minSamplingDepth = 8,
  svgPathProps = {}
}) {
  const { viewTransform } = useTransformContext();
  const pixelsPerSquare = -vec.det(viewTransform);
  const [tMin, tMax] = t;
  const errorThreshold = 0.1 / pixelsPerSquare;
  const svgPath = React9.useMemo(
    () => sampleParametric(xy, [tMin, tMax], minSamplingDepth, maxSamplingDepth, errorThreshold),
    [xy, minSamplingDepth, maxSamplingDepth, errorThreshold, tMin, tMax]
  );
  return (0, import_jsx_runtime6.jsx)(
    "path",
    {
      d: svgPath,
      strokeWidth: weight,
      fill: "none",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      strokeDasharray: style === "dashed" ? "1,10" : void 0,
      ...svgPathProps,
      style: {
        stroke: color || "var(--mafs-fg)",
        strokeOpacity: opacity,
        vectorEffect: "non-scaling-stroke",
        transform: "var(--mafs-view-transform)",
        ...svgPathProps.style || {}
      }
    }
  );
}
function OfX({ y, ...props }) {
  const {
    xPaneRange: [xMin, xMax]
  } = usePaneContext();
  const xy = React10.useCallback((x) => [x, y(x)], [y]);
  const t = React10.useMemo(() => [xMin, xMax], [xMin, xMax]);
  return (0, import_jsx_runtime7.jsx)(Parametric, { xy, t, ...props });
}
function OfY({ x, ...props }) {
  const {
    yPaneRange: [yMin, yMax]
  } = usePaneContext();
  const xy = React10.useCallback((y) => [x(y), y], [x]);
  const t = React10.useMemo(() => [yMin, yMax], [yMin, yMax]);
  return (0, import_jsx_runtime7.jsx)(Parametric, { xy, t, ...props });
}
var Theme = {
  foreground: "var(--mafs-fg)",
  background: "var(--mafs-bg)",
  red: "var(--mafs-red)",
  orange: "var(--mafs-orange)",
  green: "var(--mafs-green)",
  blue: "var(--mafs-blue)",
  indigo: "var(--mafs-indigo)",
  violet: "var(--mafs-violet)",
  pink: "var(--mafs-pink)",
  yellow: "var(--mafs-yellow)"
};
var xyOpacityDefault = () => 1;
function VectorField({
  xy,
  step = 1,
  xyOpacity = xyOpacityDefault,
  opacityStep = xyOpacity === xyOpacityDefault ? 1 : 0.2,
  color = Theme.foreground
}) {
  const { viewTransform: pixelMatrix } = useTransformContext();
  const { xPanes, yPanes } = usePaneContext();
  opacityStep = Math.min(1, Math.max(0.01, opacityStep));
  const opacityGrainularity = Math.ceil(1 / opacityStep);
  const layers = generateOpacityLayers(opacityGrainularity);
  function fieldForRegion(xMin, xMax, yMin, yMax) {
    for (let x = Math.floor(xMin); x <= Math.ceil(xMax); x += step) {
      for (let y = Math.floor(yMin); y <= Math.ceil(yMax); y += step) {
        const tail = [x, y];
        const trueOffset = xy([x, y]);
        const trueMag = vec.mag(trueOffset);
        const scaledOffset = vec.scale(vec.normalize(trueOffset), Math.min(trueMag, step * 0.75));
        const tip = vec.add(tail, scaledOffset);
        const pixelTail = vec.transform(tail, pixelMatrix);
        const pixelTipOffset = vec.transform(scaledOffset, pixelMatrix);
        const pixelSize = vec.mag(pixelTipOffset);
        const pixelTip = vec.transform(tip, pixelMatrix);
        const arrowVector = vec.scale(vec.normalize(pixelTipOffset), Math.min(pixelSize, 5));
        const left = vec.add(pixelTip, vec.rotate(arrowVector, 5 / 6 * Math.PI));
        const right = vec.add(pixelTip, vec.rotate(arrowVector, -(5 / 6) * Math.PI));
        const trueOpacity = xyOpacity([x, y]);
        const layer = findClosetLayer(layers, trueOpacity);
        layer.d += ` M ${pixelTail[0]} ${pixelTail[1]} L ${pixelTip[0]} ${pixelTip[1]}  L ${left[0]} ${left[1]}  L ${right[0]} ${right[1]}  L ${pixelTip[0]} ${pixelTip[1]} `;
      }
    }
  }
  for (const [xMin, xMax] of xPanes) {
    for (const [yMin, yMax] of yPanes) {
      fieldForRegion(xMin, xMax, yMin, yMax);
    }
  }
  return (0, import_jsx_runtime8.jsx)(import_jsx_runtime8.Fragment, { children: layers.map((layer, index) => (0, import_jsx_runtime8.jsx)(
    "path",
    {
      d: layer.d,
      style: {
        stroke: color,
        fill: color,
        opacity: layer.opacity,
        fillOpacity: layer.opacity,
        strokeOpacity: layer.opacity
      },
      strokeLinecap: "round",
      strokeLinejoin: "round"
    },
    index
  )) });
}
function generateOpacityLayers(opacityGrainularity) {
  const layers = [];
  const step = 1 / opacityGrainularity;
  for (let i = 1; i > 0; i -= step) {
    const layer = {
      d: "",
      opacity: i
    };
    layers.push(layer);
  }
  return layers;
}
function findClosetLayer(layers, pointOpacity) {
  pointOpacity = clamp2(pointOpacity, 0, 1);
  const index = layers.length - 1 - Math.round(pointOpacity * (layers.length - 1));
  return layers[index];
}
function Inequality({
  x,
  y,
  color = Theme.foreground,
  weight = 2,
  strokeColor = color,
  strokeOpacity = 1,
  fillColor = color,
  fillOpacity = 0.15,
  minSamplingDepth = 10,
  maxSamplingDepth = 14,
  upperColor = strokeColor,
  upperOpacity = strokeOpacity,
  upperWeight = weight,
  lowerColor = strokeColor,
  lowerOpacity = strokeOpacity,
  lowerWeight = weight,
  svgUpperPathProps = {},
  svgLowerPathProps = {},
  svgFillPathProps = {}
}) {
  const {
    xPaneRange: [xMin, xMax],
    yPaneRange: [yMin, yMax]
  } = usePaneContext();
  const domain = y ? [xMin, xMax] : [yMin, yMax];
  const range2 = y ? [yMin, yMax] : [xMin, xMax];
  const fn = y ? y : x;
  invariant(
    fn && x === void 0 !== (y === void 0),
    "You must pass either an x or y set of functions to Inequality (but not both)"
  );
  invariant(
    (fn["<"] === void 0 || fn["<="] === void 0) && (fn[">"] === void 0 || fn[">="] === void 0),
    "You cannot pass both an inequality and an equality operator to Inequality"
  );
  let upperBoundType = 0;
  if ("<=" in fn)
    upperBoundType = 1;
  if ("<" in fn)
    upperBoundType = 2;
  let lowerBoundType = 0;
  if (">=" in fn)
    lowerBoundType = 1;
  if (">" in fn)
    lowerBoundType = 2;
  let greaterFn = fn["<"] ?? fn["<="] ?? (() => range2[1]);
  let lesserFn = fn[">"] ?? fn[">="] ?? (() => range2[0]);
  if (typeof greaterFn === "number") {
    const greater = greaterFn;
    greaterFn = () => greater;
  }
  if (typeof lesserFn === "number") {
    const lesser = lesserFn;
    lesserFn = () => lesser;
  }
  const svgPath = sampleInequality(
    y ? "x" : "y",
    greaterFn,
    lesserFn,
    domain,
    minSamplingDepth,
    maxSamplingDepth,
    0.1
  );
  return (0, import_jsx_runtime9.jsxs)("g", { children: [
    (0, import_jsx_runtime9.jsx)(
      "path",
      {
        d: svgPath.fill,
        style: {
          fill: fillColor || "var(--mafs-fg)",
          fillOpacity,
          stroke: "none",
          transform: "var(--mafs-view-transform)",
          vectorEffect: "non-scaling-stroke",
          ...svgFillPathProps == null ? void 0 : svgFillPathProps.style
        },
        ...svgFillPathProps
      }
    ),
    upperBoundType != 0 && (0, import_jsx_runtime9.jsx)(
      "path",
      {
        d: svgPath.upper,
        strokeWidth: upperWeight,
        strokeLinecap: "round",
        strokeLinejoin: "round",
        strokeDasharray: upperBoundType === 2 ? "4,8" : "",
        style: {
          fill: "none",
          stroke: upperColor,
          strokeOpacity: upperOpacity,
          transform: "var(--mafs-view-transform)",
          vectorEffect: "non-scaling-stroke",
          ...svgUpperPathProps == null ? void 0 : svgUpperPathProps.style
        },
        ...svgUpperPathProps
      }
    ),
    lowerBoundType != 0 && (0, import_jsx_runtime9.jsx)(
      "path",
      {
        d: svgPath.lower,
        strokeWidth: lowerWeight,
        strokeLinecap: "round",
        strokeLinejoin: "round",
        strokeDasharray: lowerBoundType === 2 ? "4,8" : "",
        style: {
          fill: "none",
          stroke: lowerColor,
          strokeOpacity: lowerOpacity,
          transform: "var(--mafs-view-transform)",
          vectorEffect: "non-scaling-stroke",
          ...svgLowerPathProps == null ? void 0 : svgLowerPathProps.style
        },
        ...svgLowerPathProps
      }
    )
  ] });
}
var Plot = {
  OfX,
  OfY,
  Parametric,
  VectorField,
  Inequality
};
Plot.OfX.displayName = "Plot.OfX";
Plot.OfY.displayName = "Plot.OfY";
Plot.Parametric.displayName = "Plot.Parametric";
Plot.VectorField.displayName = "Plot.VectorField";
Plot.Inequality.displayName = "Plot.Inequality";
function ThroughPoints({
  point1,
  point2,
  color = Theme.foreground,
  style = "solid",
  weight = 2,
  opacity = 1
}) {
  const { xPaneRange, yPaneRange } = usePaneContext();
  const [xMin, xMax] = xPaneRange;
  const [yMin, yMax] = yPaneRange;
  const { userTransform } = useTransformContext();
  const tPoint1 = vec.transform(point1, userTransform);
  const tPoint2 = vec.transform(point2, userTransform);
  const slope = (tPoint2[1] - tPoint1[1]) / (tPoint2[0] - tPoint1[0]);
  let offscreen1;
  let offscreen2;
  if (Math.abs(Math.atan(slope)) > Math.PI / 4) {
    offscreen1 = [(yMin - tPoint1[1]) / slope + tPoint1[0], yMin];
    offscreen2 = [(yMax - tPoint1[1]) / slope + tPoint1[0], yMax];
  } else {
    offscreen1 = [xMin, slope * (xMin - tPoint1[0]) + tPoint1[1]];
    offscreen2 = [xMax, slope * (xMax - tPoint1[0]) + tPoint1[1]];
  }
  return (0, import_jsx_runtime10.jsx)(
    "line",
    {
      x1: round(offscreen1[0], 2),
      y1: round(offscreen1[1], 2),
      x2: round(offscreen2[0], 2),
      y2: round(offscreen2[1], 2),
      style: {
        stroke: color,
        transform: "var(--mafs-view-transform)",
        vectorEffect: "non-scaling-stroke"
      },
      strokeWidth: weight,
      opacity,
      strokeDasharray: style === "dashed" ? "4,3" : void 0
    }
  );
}
function PointAngle({ point, angle, ...rest }) {
  const point2 = vec.add(point, vec.rotate([1, 0], angle));
  return (0, import_jsx_runtime11.jsx)(ThroughPoints, { point1: point, point2, ...rest });
}
function PointSlope({ point, slope, ...rest }) {
  return (0, import_jsx_runtime12.jsx)(PointAngle, { point, angle: Math.atan(slope), ...rest });
}
function Segment({
  point1,
  point2,
  color = Theme.foreground,
  style = "solid",
  weight = 2,
  opacity = 1
}) {
  const { viewTransform: pixelMatrix, userTransform } = useTransformContext();
  const transform = vec.matrixMult(pixelMatrix, userTransform);
  const scaledPoint1 = vec.transform(point1, transform);
  const scaledPoint2 = vec.transform(point2, transform);
  return (0, import_jsx_runtime13.jsx)(
    "line",
    {
      x1: round(scaledPoint1[0], 2),
      y1: round(scaledPoint1[1], 2),
      x2: round(scaledPoint2[0], 2),
      y2: round(scaledPoint2[1], 2),
      style: { stroke: color },
      strokeWidth: weight,
      opacity,
      strokeDasharray: style === "dashed" ? "1,10" : void 0
    }
  );
}
var Line = {
  PointAngle,
  PointSlope,
  ThroughPoints,
  Segment
};
Line.PointAngle.displayName = "Line.PointAngle";
Line.PointSlope.displayName = "Line.PointSlope";
Line.Segment.displayName = "Line.Segment";
Line.ThroughPoints.displayName = "Line.ThroughPoints";
function Ellipse({
  center,
  radius,
  angle = 0,
  strokeStyle = "solid",
  strokeOpacity = 1,
  weight = 2,
  color = Theme.foreground,
  fillOpacity = 0.15,
  svgEllipseProps = {}
}) {
  const { viewTransform: toPx, userTransform } = useTransformContext();
  const transform = vec.matrixBuilder().translate(...center).mult(userTransform).scale(1, -1).mult(toPx).scale(1, -1).get();
  const cssTransform = `
    ${vec.toCSS(transform)}
    rotate(${angle * (180 / Math.PI)})
  `;
  return (0, import_jsx_runtime14.jsx)(
    "ellipse",
    {
      cx: 0,
      cy: 0,
      rx: radius[0],
      ry: radius[1],
      strokeWidth: weight,
      strokeDasharray: strokeStyle === "dashed" ? "4,3" : void 0,
      transform: cssTransform,
      ...svgEllipseProps,
      style: {
        stroke: color,
        fill: color,
        fillOpacity,
        strokeOpacity,
        vectorEffect: "non-scaling-stroke",
        ...svgEllipseProps.style || {}
      }
    }
  );
}
Ellipse.displayName = "Ellipse";
function Circle({ radius, ...rest }) {
  return (0, import_jsx_runtime15.jsx)(Ellipse, { radius: [radius, radius], ...rest });
}
Circle.displayName = "Circle";
function PolyBase({
  element: PolyElement,
  points,
  color = Theme.foreground,
  weight = 2,
  fillOpacity = 0.15,
  strokeOpacity = 1,
  strokeStyle = "solid",
  svgPolyProps = {}
}) {
  const { userTransform } = useTransformContext();
  const scaledPoints = points.map((point) => vec.transform(point, userTransform).join(" ")).join(" ");
  return (0, import_jsx_runtime16.jsx)(
    PolyElement,
    {
      points: scaledPoints,
      strokeWidth: weight,
      fillOpacity,
      strokeDasharray: strokeStyle === "dashed" ? "4,3" : void 0,
      strokeLinejoin: "round",
      ...svgPolyProps,
      style: {
        fill: color,
        fillOpacity,
        stroke: color,
        strokeOpacity,
        vectorEffect: "non-scaling-stroke",
        transform: "var(--mafs-view-transform)",
        ...svgPolyProps.style || {}
      }
    }
  );
}
function Polygon({ svgPolygonProps, ...otherProps }) {
  return (0, import_jsx_runtime17.jsx)(PolyBase, { element: "polygon", svgPolyProps: svgPolygonProps, ...otherProps });
}
Polygon.displayName = "Polygon";
function Polyline({ fillOpacity = 0, svgPolylineProps, ...otherProps }) {
  return (0, import_jsx_runtime18.jsx)(
    PolyBase,
    {
      element: "polyline",
      fillOpacity,
      svgPolyProps: svgPolylineProps,
      ...otherProps
    }
  );
}
Polyline.displayName = "Polyline";
function Point({
  x,
  y,
  color = Theme.foreground,
  opacity = 1,
  svgCircleProps = {}
}) {
  const { viewTransform: pixelMatrix, userTransform: transform } = useTransformContext();
  const [cx, cy] = vec.transform([x, y], vec.matrixMult(pixelMatrix, transform));
  return (0, import_jsx_runtime19.jsx)(
    "circle",
    {
      cx,
      cy,
      r: 6,
      ...svgCircleProps,
      style: { fill: color, opacity, ...svgCircleProps.style }
    }
  );
}
Point.displayName = "Point";
var incrementer2 = 0;
function Vector({
  tail = [0, 0],
  tip,
  color = Theme.foreground,
  weight = 2,
  style = "solid",
  opacity = 1,
  svgLineProps = {}
}) {
  const { userTransform, viewTransform } = useTransformContext();
  const combinedTransform = vec.matrixMult(viewTransform, userTransform);
  const pixelTail = vec.transform(tail, combinedTransform);
  const pixelTip = vec.transform(tip, combinedTransform);
  const id = React11.useMemo(() => `mafs-triangle-${incrementer2++}`, []);
  return (0, import_jsx_runtime20.jsxs)(import_jsx_runtime20.Fragment, { children: [
    (0, import_jsx_runtime20.jsx)("defs", { children: (0, import_jsx_runtime20.jsx)("marker", { id, markerWidth: "8", markerHeight: "8", refX: "8", refY: "4", orient: "auto", children: (0, import_jsx_runtime20.jsx)("path", { d: "M 0 0 L 8 4 L 0 8 z", fill: color || "var(--mafs-fg)" }) }) }),
    (0, import_jsx_runtime20.jsx)(
      "line",
      {
        x1: pixelTail[0],
        y1: pixelTail[1],
        x2: pixelTip[0],
        y2: pixelTip[1],
        strokeWidth: weight,
        markerEnd: `url(#${id})`,
        strokeDasharray: style === "dashed" ? "4,3" : void 0,
        ...svgLineProps,
        style: {
          stroke: color || "var(--mafs-fg)",
          strokeOpacity: opacity,
          ...(svgLineProps == null ? void 0 : svgLineProps.style) || {},
          vectorEffect: "non-scaling-stroke"
        }
      }
    )
  ] });
}
Vector.displayName = "Vector";
function Text({
  children,
  x,
  y,
  color,
  size = 30,
  svgTextProps = {},
  attach,
  attachDistance = 0
}) {
  const { viewTransform: pixelMatrix, userTransform: transformContext } = useTransformContext();
  let xOffset = 0;
  let textAnchor = "middle";
  if (attach == null ? void 0 : attach.includes("w")) {
    textAnchor = "end";
    xOffset = -1;
  } else if (attach == null ? void 0 : attach.includes("e")) {
    textAnchor = "start";
    xOffset = 1;
  }
  let yOffset = 0;
  let dominantBaseline = "middle";
  if (attach == null ? void 0 : attach.includes("n")) {
    dominantBaseline = "baseline";
    yOffset = 1;
  } else if (attach == null ? void 0 : attach.includes("s")) {
    dominantBaseline = "hanging";
    yOffset = -1;
  }
  let [pixelX, pixelY] = [0, 0];
  if (xOffset !== 0 || yOffset !== 0) {
    ;
    [pixelX, pixelY] = vec.withMag([xOffset, yOffset], attachDistance);
  }
  const center = vec.transform([x, y], vec.matrixMult(pixelMatrix, transformContext));
  return (0, import_jsx_runtime21.jsx)(
    "text",
    {
      x: center[0] + pixelX,
      y: center[1] + pixelY,
      fontSize: size,
      dominantBaseline,
      textAnchor,
      style: {
        fill: color || "var(--mafs-fg)",
        vectorEffect: "non-scaling-stroke"
      },
      className: "mafs-shadow",
      ...svgTextProps,
      children
    }
  );
}
Text.displayName = "Text";
function MovablePoint({
  point,
  onMove,
  constrain = (point2) => point2,
  color = Theme.pink
}) {
  const { viewTransform, userTransform } = useTransformContext();
  const { xSpan, ySpan } = useSpanContext();
  const inverseViewTransform = vec.matrixInvert(viewTransform);
  invariant(inverseViewTransform, "The view transform must be invertible.");
  const inverseTransform = React12.useMemo(() => getInverseTransform(userTransform), [userTransform]);
  const combinedTransform = React12.useMemo(
    () => vec.matrixMult(viewTransform, userTransform),
    [viewTransform, userTransform]
  );
  const [dragging, setDragging] = React12.useState(false);
  const [displayX, displayY] = vec.transform(point, combinedTransform);
  const pickup = React12.useRef([0, 0]);
  const ref = React12.useRef(null);
  useDrag(
    (state) => {
      const { type, event } = state;
      event == null ? void 0 : event.stopPropagation();
      const isKeyboard = type.includes("key");
      if (isKeyboard) {
        event == null ? void 0 : event.preventDefault();
        const { direction: yDownDirection, altKey, metaKey, shiftKey } = state;
        const direction = [yDownDirection[0], -yDownDirection[1]];
        const span = Math.abs(direction[0]) ? xSpan : ySpan;
        let divisions = 50;
        if (altKey || metaKey)
          divisions = 200;
        if (shiftKey)
          divisions = 10;
        const min = span / (divisions * 2);
        const tests = range(span / divisions, span / 2, span / divisions);
        for (const dx of tests) {
          const testMovement = vec.scale(direction, dx);
          const testPoint = constrain(
            vec.transform(
              vec.add(vec.transform(point, userTransform), testMovement),
              inverseTransform
            )
          );
          if (vec.dist(testPoint, point) > min) {
            onMove(testPoint);
            break;
          }
        }
      } else {
        const { last, movement: pixelMovement, first } = state;
        setDragging(!last);
        if (first)
          pickup.current = vec.transform(point, userTransform);
        if (vec.mag(pixelMovement) === 0)
          return;
        const movement = vec.transform(pixelMovement, inverseViewTransform);
        onMove(constrain(vec.transform(vec.add(pickup.current, movement), inverseTransform)));
      }
    },
    { target: ref, eventOptions: { passive: false } }
  );
  const ringSize = 15;
  return (0, import_jsx_runtime22.jsxs)(
    "g",
    {
      ref,
      style: {
        "--movable-point-color": color,
        "--movable-point-ring-size": `${ringSize}px`
      },
      className: `mafs-movable-point ${dragging ? "mafs-movable-point-dragging" : ""}`,
      tabIndex: 0,
      children: [
        (0, import_jsx_runtime22.jsx)("circle", { className: "mafs-movable-point-hitbox", r: 30, cx: displayX, cy: displayY }),
        (0, import_jsx_runtime22.jsx)(
          "circle",
          {
            className: "mafs-movable-point-focus",
            r: ringSize + 1,
            cx: displayX,
            cy: displayY
          }
        ),
        (0, import_jsx_runtime22.jsx)("circle", { className: "mafs-movable-point-ring", r: ringSize, cx: displayX, cy: displayY }),
        (0, import_jsx_runtime22.jsx)("circle", { className: "mafs-movable-point-point", r: 6, cx: displayX, cy: displayY })
      ]
    }
  );
}
MovablePoint.displayName = "MovablePoint";
function getInverseTransform(transform) {
  const invert = vec.matrixInvert(transform);
  invariant(
    invert !== null,
    "Could not invert transform matrix. Your movable point's transformation matrix might be degenerative (mapping 2D space to a line)."
  );
  return invert;
}
function useMovablePoint(initialPoint, { constrain, color = Theme.pink } = {}) {
  const [initialX, initialY] = initialPoint;
  const [point, setPoint] = React13.useState(initialPoint);
  const [x, y] = point;
  const constraintFunction = React13.useMemo(() => {
    if (constrain === "horizontal") {
      return ([x2]) => [x2, initialY];
    } else if (constrain === "vertical") {
      return ([, y2]) => [initialX, y2];
    } else if (typeof constrain === "function") {
      return constrain;
    }
    return ([x2, y2]) => [x2, y2];
  }, [constrain, initialX, initialY]);
  const element = React13.useMemo(() => {
    return (0, import_jsx_runtime23.jsx)(MovablePoint, { ...{ point, color }, constrain: constraintFunction, onMove: setPoint });
  }, [point, color, constraintFunction]);
  return {
    x,
    y,
    point: [x, y],
    element,
    setPoint
  };
}
function useStopwatch(options) {
  const { startTime = 0, endTime = Infinity } = options || {};
  const startClockTime = React14.useRef(null);
  const [time, setTime] = React14.useState(startTime);
  const [playing, setPlaying] = React14.useState(false);
  React14.useEffect(() => {
    let request = -1;
    function tick(now) {
      now = now / 1e3;
      if (!startClockTime.current)
        startClockTime.current = now;
      const deltaTime = now - startClockTime.current;
      if (deltaTime >= endTime) {
        startClockTime.current = null;
        setTime(endTime);
        setPlaying(false);
        return;
      }
      setTime(Math.min(deltaTime, endTime));
      request = window.requestAnimationFrame(tick);
    }
    if (playing) {
      request = window.requestAnimationFrame(tick);
    } else {
      window.cancelAnimationFrame(request);
    }
    return () => window.cancelAnimationFrame(request);
  }, [playing, endTime]);
  const start = React14.useCallback(() => setPlaying(true), []);
  const stop = React14.useCallback(() => {
    startClockTime.current = null;
    setPlaying(false);
    setTime(startTime);
  }, [startTime]);
  return { time, setTime: (time2) => setTime(time2 * 1e3), start, stop };
}
function Transform(props) {
  const { userTransform, viewTransform } = useTransformContext();
  let builder = vec.matrixBuilder();
  const { matrix, children, ...transforms } = props;
  if (matrix)
    builder = builder.mult(matrix);
  for (const [name, value] of Object.entries(transforms)) {
    if (value == null)
      continue;
    switch (name) {
      case "translate":
        builder = builder.translate(...value);
        break;
      case "scale":
        if (typeof value === "number")
          builder = builder.scale(value, value);
        else
          builder = builder.scale(...value);
        break;
      case "shear":
        builder = builder.shear(...value);
        break;
      case "rotate":
        builder = builder.rotate(value);
        break;
    }
  }
  builder = builder.mult(userTransform);
  const newUserTransform = builder.get();
  return (0, import_jsx_runtime24.jsx)(TransformContext.Provider, { value: { userTransform: newUserTransform, viewTransform }, children: (0, import_jsx_runtime24.jsx)("g", { style: { "--mafs-user-transform": vec.toCSS(newUserTransform) }, children }) });
}
Transform.displayName = "Transform";
function ViewportInfo({ precision = 3 }) {
  const { xMin, xMax, yMin, yMax } = useCoordinateContext();
  const { viewTransform } = useTransformContext();
  const { xPanes, yPanes } = usePaneContext();
  const [x, y] = vec.transform([xMin, yMin], viewTransform);
  const xPanesString = xPanes.map((pane) => `(${pane.join(", ")})`).join("   ");
  const yPanesString = yPanes.map((pane) => `(${pane.join(", ")})`).join("   ");
  return (0, import_jsx_runtime25.jsxs)("g", { className: "mafs-shadow", fontFamily: "monospace", children: [
    (0, import_jsx_runtime25.jsxs)("text", { x: x + 10, y: y - 70, children: [
      "x: (",
      xMin.toFixed(precision),
      ", ",
      xMax.toFixed(precision),
      ")"
    ] }),
    (0, import_jsx_runtime25.jsxs)("text", { x: x + 10, y: y - 50, children: [
      "y: (",
      yMin.toFixed(precision),
      ", ",
      yMax.toFixed(precision),
      ")"
    ] }),
    (0, import_jsx_runtime25.jsxs)("text", { x: x + 10, y: y - 30, children: [
      "xPanes: ",
      xPanesString
    ] }),
    (0, import_jsx_runtime25.jsxs)("text", { x: x + 10, y: y - 10, children: [
      "yPanes: ",
      yPanesString
    ] })
  ] });
}
function TransformWidget({ children }) {
  const t = useMovablePoint([0, 0]);
  const s = useMovablePoint([1, 1], { color: Theme.blue });
  const r = useMovablePoint([1, 0], {
    color: Theme.green,
    constrain: (p) => vec.normalize(p)
  });
  const angle = Math.atan2(r.point[1], r.point[0]);
  return (0, import_jsx_runtime26.jsxs)(import_jsx_runtime26.Fragment, { children: [
    (0, import_jsx_runtime26.jsxs)(Transform, { translate: t.point, children: [
      (0, import_jsx_runtime26.jsxs)(Transform, { rotate: angle, children: [
        (0, import_jsx_runtime26.jsxs)(Transform, { scale: s.point, children: [
          children,
          (0, import_jsx_runtime26.jsx)(
            Polygon,
            {
              points: [
                [0, 0],
                [0, 1],
                [1, 1],
                [1, 0]
              ],
              color: Theme.blue
            }
          )
        ] }),
        (0, import_jsx_runtime26.jsx)(
          Circle,
          {
            center: [0, 0],
            radius: 1,
            strokeStyle: "dashed",
            strokeOpacity: 0.5,
            fillOpacity: 0,
            color: Theme.green
          }
        ),
        s.element
      ] }),
      r.element
    ] }),
    t.element
  ] });
}
var Debug = {
  ViewportInfo,
  TransformWidget
};
Debug.ViewportInfo.displayName = "Debug.ViewportInfo";
Debug.TransformWidget.displayName = "Debug.TransformWidget";
function LaTeX({ at: center, tex, color = Theme.foreground, katexOptions }) {
  const ref = React15.useRef(null);
  const { viewTransform, userTransform } = useTransformContext();
  const combinedTransform = vec.matrixMult(viewTransform, userTransform);
  const width = 99999;
  const height = 99999;
  React15.useEffect(() => {
    if (!ref.current)
      return;
    katex.render(tex, ref.current, katexOptions);
  }, [katexOptions, tex]);
  const pixelCenter = vec.add(vec.transform(center, combinedTransform), [-width / 2, -height / 2]);
  return (0, import_jsx_runtime27.jsx)(
    "foreignObject",
    {
      x: pixelCenter[0],
      y: pixelCenter[1],
      width,
      height,
      pointerEvents: "none",
      children: (0, import_jsx_runtime27.jsx)(
        "div",
        {
          style: {
            fontSize: "1.3em",
            width,
            height,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            position: "fixed",
            color,
            textShadow: `, 0 0 2px ${Theme.background}`.repeat(8).slice(2)
          },
          children: (0, import_jsx_runtime27.jsx)("span", { ref })
        }
      )
    }
  );
}
export {
  Circle,
  Coordinates,
  Debug,
  Ellipse,
  LaTeX,
  Line,
  Mafs,
  MovablePoint,
  Plot,
  Point,
  Polygon,
  Polyline,
  Text,
  Theme,
  Transform,
  Vector,
  autoPi as labelPi,
  useMovablePoint,
  usePaneContext,
  useStopwatch,
  useTransformContext,
  vec
};
//# sourceMappingURL=mafs.js.map
